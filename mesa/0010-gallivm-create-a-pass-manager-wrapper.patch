From 98d7ef301fa42cce4881324289fd78b5a13dd855 Mon Sep 17 00:00:00 2001
From: Dave Airlie <airlied@redhat.com>
Date: Thu, 20 Jun 2024 15:05:10 +1000
Subject: [PATCH 10/26] gallivm: create a pass manager wrapper.

With the introduction of the orc jit and looking at the mess that
is integrating with LLVM pass mgmt, encapsulate the passmgr
interactions in an internal abstraction so it can be shared,
and the compiler code isn't so messy to read.

Acked-by: Konstantin Seurer <konstantin.seurer@gmail.com>
Part-of: <https://gitlab.freedesktop.org/mesa/mesa/-/merge_requests/29796>
---
 src/gallium/auxiliary/gallivm/lp_bld.h        |  13 +-
 src/gallium/auxiliary/gallivm/lp_bld_init.c   | 164 +-----------
 src/gallium/auxiliary/gallivm/lp_bld_init.h   |   8 +-
 .../auxiliary/gallivm/lp_bld_passmgr.c        | 234 ++++++++++++++++++
 .../auxiliary/gallivm/lp_bld_passmgr.h        |  55 ++++
 src/gallium/auxiliary/meson.build             |   2 +
 6 files changed, 302 insertions(+), 174 deletions(-)
 create mode 100644 src/gallium/auxiliary/gallivm/lp_bld_passmgr.c
 create mode 100644 src/gallium/auxiliary/gallivm/lp_bld_passmgr.h

diff --git a/src/gallium/auxiliary/gallivm/lp_bld.h b/src/gallium/auxiliary/gallivm/lp_bld.h
index fd2a4943f56..24e64fec2bf 100644
--- a/src/gallium/auxiliary/gallivm/lp_bld.h
+++ b/src/gallium/auxiliary/gallivm/lp_bld.h
@@ -83,19 +83,12 @@
 #define LLVMInsertBasicBlock ILLEGAL_LLVM_FUNCTION
 #define LLVMCreateBuilder ILLEGAL_LLVM_FUNCTION
 
-#if LLVM_VERSION_MAJOR >= 15
-#define GALLIVM_HAVE_CORO 0
-#define GALLIVM_USE_NEW_PASS 1
-#elif LLVM_VERSION_MAJOR >= 8
-#define GALLIVM_HAVE_CORO 1
-#define GALLIVM_USE_NEW_PASS 0
+#if LLVM_VERSION_MAJOR >= 8
+#define GALLIVM_COROUTINES 1
 #else
-#define GALLIVM_HAVE_CORO 0
-#define GALLIVM_USE_NEW_PASS 0
+#define GALLIVM_COROUTINES 0
 #endif
 
-#define GALLIVM_COROUTINES (GALLIVM_HAVE_CORO || GALLIVM_USE_NEW_PASS)
-
 /* LLVM is transitioning to "opaque pointers", and as such deprecates
  * LLVMBuildGEP, LLVMBuildCall, LLVMBuildLoad, replacing them with
  * LLVMBuildGEP2, LLVMBuildCall2, LLVMBuildLoad2 respectivelly.
diff --git a/src/gallium/auxiliary/gallivm/lp_bld_init.c b/src/gallium/auxiliary/gallivm/lp_bld_init.c
index c255696f72e..6326d0485b8 100644
--- a/src/gallium/auxiliary/gallivm/lp_bld_init.c
+++ b/src/gallium/auxiliary/gallivm/lp_bld_init.c
@@ -43,18 +43,6 @@
 #include <llvm/Config/llvm-config.h>
 #include <llvm-c/Analysis.h>
 #include <llvm-c/BitWriter.h>
-#if GALLIVM_USE_NEW_PASS == 1
-#include <llvm-c/Transforms/PassBuilder.h>
-#elif GALLIVM_HAVE_CORO == 1
-#include <llvm-c/Transforms/Scalar.h>
-#if LLVM_VERSION_MAJOR >= 7
-#include <llvm-c/Transforms/Utils.h>
-#endif
-#if LLVM_VERSION_MAJOR <= 8 && (DETECT_ARCH_AARCH64 || DETECT_ARCH_ARM || DETECT_ARCH_S390 || DETECT_ARCH_MIPS64)
-#include <llvm-c/Transforms/IPO.h>
-#endif
-#include <llvm-c/Transforms/Coroutines.h>
-#endif
 
 static bool gallivm_initialized = false;
 
@@ -83,23 +71,6 @@ enum LLVM_CodeGenOpt_Level {
 static bool
 create_pass_manager(struct gallivm_state *gallivm)
 {
-#if GALLIVM_USE_NEW_PASS == 0
-   assert(!gallivm->passmgr);
-   assert(gallivm->target);
-
-   gallivm->passmgr = LLVMCreateFunctionPassManagerForModule(gallivm->module);
-   if (!gallivm->passmgr)
-      return false;
-
-#if GALLIVM_HAVE_CORO == 1
-   gallivm->cgpassmgr = LLVMCreatePassManager();
-#endif
-   /*
-    * TODO: some per module pass manager with IPO passes might be helpful -
-    * the generated texture functions may benefit from inlining if they are
-    * simple, or constant propagation into them, etc.
-    */
-
    {
       char *td_str;
       // New ones from the Module.
@@ -108,58 +79,7 @@ create_pass_manager(struct gallivm_state *gallivm)
       free(td_str);
    }
 
-#if GALLIVM_HAVE_CORO == 1
-#if LLVM_VERSION_MAJOR <= 8 && (DETECT_ARCH_AARCH64 || DETECT_ARCH_ARM || DETECT_ARCH_S390 || DETECT_ARCH_MIPS64)
-   LLVMAddArgumentPromotionPass(gallivm->cgpassmgr);
-   LLVMAddFunctionAttrsPass(gallivm->cgpassmgr);
-#endif
-   LLVMAddCoroEarlyPass(gallivm->cgpassmgr);
-   LLVMAddCoroSplitPass(gallivm->cgpassmgr);
-   LLVMAddCoroElidePass(gallivm->cgpassmgr);
-#endif
-
-   if ((gallivm_perf & GALLIVM_PERF_NO_OPT) == 0) {
-      /*
-       * TODO: Evaluate passes some more - keeping in mind
-       * both quality of generated code and compile times.
-       */
-      /*
-       * NOTE: if you change this, don't forget to change the output
-       * with GALLIVM_DEBUG_DUMP_BC in gallivm_compile_module.
-       */
-      LLVMAddScalarReplAggregatesPass(gallivm->passmgr);
-      LLVMAddEarlyCSEPass(gallivm->passmgr);
-      LLVMAddCFGSimplificationPass(gallivm->passmgr);
-      /*
-       * FIXME: LICM is potentially quite useful. However, for some
-       * rather crazy shaders the compile time can reach _hours_ per shader,
-       * due to licm implying lcssa (since llvm 3.5), which can take forever.
-       * Even for sane shaders, the cost of licm is rather high (and not just
-       * due to lcssa, licm itself too), though mostly only in cases when it
-       * can actually move things, so having to disable it is a pity.
-       * LLVMAddLICMPass(gallivm->passmgr);
-       */
-      LLVMAddReassociatePass(gallivm->passmgr);
-      LLVMAddPromoteMemoryToRegisterPass(gallivm->passmgr);
-#if LLVM_VERSION_MAJOR <= 11
-      LLVMAddConstantPropagationPass(gallivm->passmgr);
-#else
-      LLVMAddInstructionSimplifyPass(gallivm->passmgr);
-#endif
-      LLVMAddInstructionCombiningPass(gallivm->passmgr);
-      LLVMAddGVNPass(gallivm->passmgr);
-   }
-   else {
-      /* We need at least this pass to prevent the backends to fail in
-       * unexpected ways.
-       */
-      LLVMAddPromoteMemoryToRegisterPass(gallivm->passmgr);
-   }
-#if GALLIVM_HAVE_CORO == 1
-   LLVMAddCoroCleanupPass(gallivm->passmgr);
-#endif
-#endif
-   return true;
+   return lp_passmgr_create(gallivm->module, &gallivm->passmgr);
 }
 
 /**
@@ -169,17 +89,7 @@ create_pass_manager(struct gallivm_state *gallivm)
 void
 gallivm_free_ir(struct gallivm_state *gallivm)
 {
-#if GALLIVM_USE_NEW_PASS == 0
-   if (gallivm->passmgr) {
-      LLVMDisposePassManager(gallivm->passmgr);
-   }
-
-#if GALLIVM_HAVE_CORO == 1
-   if (gallivm->cgpassmgr) {
-      LLVMDisposePassManager(gallivm->cgpassmgr);
-   }
-#endif
-#endif
+   lp_passmgr_dispose(gallivm->passmgr);
 
    if (gallivm->engine) {
       /* This will already destroy any associated module */
@@ -207,12 +117,7 @@ gallivm_free_ir(struct gallivm_state *gallivm)
    gallivm->target = NULL;
    gallivm->module = NULL;
    gallivm->module_name = NULL;
-#if GALLIVM_USE_NEW_PASS == 0
-#if GALLIVM_HAVE_CORO == 1
-   gallivm->cgpassmgr = NULL;
-#endif
    gallivm->passmgr = NULL;
-#endif
    gallivm->context = NULL;
    gallivm->builder = NULL;
    gallivm->cache = NULL;
@@ -456,8 +361,6 @@ gallivm_destroy(struct gallivm_state *gallivm)
 void
 gallivm_compile_module(struct gallivm_state *gallivm)
 {
-   int64_t time_begin = 0;
-
    assert(!gallivm->compiled);
 
    if (gallivm->builder) {
@@ -492,65 +395,10 @@ gallivm_compile_module(struct gallivm_state *gallivm)
                    "[-mattr=<-mattr option(s)>]");
    }
 
-   if (gallivm_debug & GALLIVM_DEBUG_PERF)
-      time_begin = os_time_get();
-
-#if GALLIVM_USE_NEW_PASS == 1
-   char passes[1024];
-   passes[0] = 0;
-
-   /*
-    * there should be some way to combine these two pass runs but I'm not seeing it,
-    * at the time of writing.
-    */
-   strcpy(passes, "default<O0>");
-
-   LLVMPassBuilderOptionsRef opts = LLVMCreatePassBuilderOptions();
-   LLVMRunPasses(gallivm->module, passes, LLVMGetExecutionEngineTargetMachine(gallivm->engine), opts);
-
-   if (!(gallivm_perf & GALLIVM_PERF_NO_OPT))
-#if LLVM_VERSION_MAJOR >= 18
-      strcpy(passes, "sroa,early-cse,simplifycfg,reassociate,mem2reg,instsimplify,instcombine<no-verify-fixpoint>");
-#else
-      strcpy(passes, "sroa,early-cse,simplifycfg,reassociate,mem2reg,instsimplify,instcombine");
-#endif
-   else
-      strcpy(passes, "mem2reg");
-
-   LLVMRunPasses(gallivm->module, passes, LLVMGetExecutionEngineTargetMachine(gallivm->engine), opts);
-   LLVMDisposePassBuilderOptions(opts);
-#else
-#if GALLIVM_HAVE_CORO == 1
-   LLVMRunPassManager(gallivm->cgpassmgr, gallivm->module);
-#endif
-   /* Run optimization passes */
-   LLVMInitializeFunctionPassManager(gallivm->passmgr);
-   LLVMValueRef func;
-   func = LLVMGetFirstFunction(gallivm->module);
-   while (func) {
-      if (0) {
-         debug_printf("optimizing func %s...\n", LLVMGetValueName(func));
-      }
-
-   /* Disable frame pointer omission on debug/profile builds */
-   /* XXX: And workaround http://llvm.org/PR21435 */
-#if MESA_DEBUG || defined(PROFILE) || DETECT_ARCH_X86 || DETECT_ARCH_X86_64
-      LLVMAddTargetDependentFunctionAttr(func, "no-frame-pointer-elim", "true");
-      LLVMAddTargetDependentFunctionAttr(func, "no-frame-pointer-elim-non-leaf", "true");
-#endif
-
-      LLVMRunFunctionPassManager(gallivm->passmgr, func);
-      func = LLVMGetNextFunction(func);
-   }
-   LLVMFinalizeFunctionPassManager(gallivm->passmgr);
-#endif
-   if (gallivm_debug & GALLIVM_DEBUG_PERF) {
-      int64_t time_end = os_time_get();
-      int time_msec = (int)((time_end - time_begin) / 1000);
-      assert(gallivm->module_name);
-      debug_printf("optimizing module %s took %d msec\n",
-                   gallivm->module_name, time_msec);
-   }
+   lp_passmgr_run(gallivm->passmgr,
+                  gallivm->module,
+                  LLVMGetExecutionEngineTargetMachine(gallivm->engine),
+                  gallivm->module_name);
 
    /* Setting the module's DataLayout to an empty string will cause the
     * ExecutionEngine to copy to the DataLayout string from its target machine
diff --git a/src/gallium/auxiliary/gallivm/lp_bld_init.h b/src/gallium/auxiliary/gallivm/lp_bld_init.h
index d0a68eea475..4fb99ad8184 100644
--- a/src/gallium/auxiliary/gallivm/lp_bld_init.h
+++ b/src/gallium/auxiliary/gallivm/lp_bld_init.h
@@ -34,6 +34,7 @@
 #include "util/u_pointer.h" // for func_pointer
 #include "util/u_cpu_detect.h"
 #include "lp_bld.h"
+#include "lp_bld_passmgr.h"
 #include <llvm-c/ExecutionEngine.h>
 
 #ifdef __cplusplus
@@ -47,12 +48,7 @@ struct gallivm_state
    LLVMModuleRef module;
    LLVMExecutionEngineRef engine;
    LLVMTargetDataRef target;
-#if GALLIVM_USE_NEW_PASS == 0
-   LLVMPassManagerRef passmgr;
-#if GALLIVM_HAVE_CORO == 1
-   LLVMPassManagerRef cgpassmgr;
-#endif
-#endif
+   struct lp_passmgr *passmgr;
    LLVMContextRef context;
    LLVMBuilderRef builder;
    LLVMMCJITMemoryManagerRef memorymgr;
diff --git a/src/gallium/auxiliary/gallivm/lp_bld_passmgr.c b/src/gallium/auxiliary/gallivm/lp_bld_passmgr.c
new file mode 100644
index 00000000000..0fd61895d73
--- /dev/null
+++ b/src/gallium/auxiliary/gallivm/lp_bld_passmgr.c
@@ -0,0 +1,234 @@
+/**************************************************************************
+ *
+ * Copyright 2009 VMware, Inc.
+ * All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sub license, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the
+ * next paragraph) shall be included in all copies or substantial portions
+ * of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+ * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.
+ * IN NO EVENT SHALL VMWARE AND/OR ITS SUPPLIERS BE LIABLE FOR
+ * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
+ * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
+ * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ **************************************************************************/
+
+#include "util/u_debug.h"
+#include "util/os_time.h"
+#include "lp_bld_debug.h"
+#include "lp_bld_passmgr.h"
+#include "lp_bld_init.h"
+
+#if LLVM_VERSION_MAJOR >= 15
+#define HAVE_CORO 0
+#define USE_NEW_PASS 1
+#elif LLVM_VERSION_MAJOR >= 8
+#define HAVE_CORO 1
+#define USE_NEW_PASS 0
+#else
+#define HAVE_CORO 0
+#define USE_NEW_PASS 0
+#endif
+
+#if USE_NEW_PASS == 1
+#include <llvm-c/Transforms/PassBuilder.h>
+#elif HAVE_CORO == 1
+#include <llvm-c/Transforms/Scalar.h>
+#if LLVM_VERSION_MAJOR >= 7
+#include <llvm-c/Transforms/Utils.h>
+#endif
+#if LLVM_VERSION_MAJOR <= 8 && (DETECT_ARCH_AARCH64 || DETECT_ARCH_ARM || DETECT_ARCH_S390 || DETECT_ARCH_MIPS64)
+#include <llvm-c/Transforms/IPO.h>
+#endif
+#include <llvm-c/Transforms/Coroutines.h>
+#endif
+
+#if USE_NEW_PASS == 0
+struct lp_passmgr {
+   LLVMPassManagerRef passmgr;
+#if HAVE_CORO == 1
+   LLVMPassManagerRef cgpassmgr;
+#endif
+};
+#else
+struct lp_passmgr;
+#endif
+
+bool
+lp_passmgr_create(LLVMModuleRef module, struct lp_passmgr **mgr_p)
+{
+   void *mgr = NULL;
+#if USE_NEW_PASS == 0
+   mgr = CALLOC_STRUCT(lp_passmgr);
+   if (!mgr)
+      return false;
+
+   mgr->passmgr = LLVMCreateFunctionPassManagerForModule(module);
+   if (!mgr->passmgr) {
+      free(mgr);
+      return false;
+   }
+
+#if HAVE_CORO == 1
+   mgr->cgpassmgr = LLVMCreatePassManager();
+#endif
+   /*
+    * TODO: some per module pass manager with IPO passes might be helpful -
+    * the generated texture functions may benefit from inlining if they are
+    * simple, or constant propagation into them, etc.
+    */
+
+#if HAVE_CORO == 1
+#if LLVM_VERSION_MAJOR <= 8 && (DETECT_ARCH_AARCH64 || DETECT_ARCH_ARM || DETECT_ARCH_S390 || DETECT_ARCH_MIPS64)
+   LLVMAddArgumentPromotionPass(mgr->cgpassmgr);
+   LLVMAddFunctionAttrsPass(mgr->cgpassmgr);
+#endif
+   LLVMAddCoroEarlyPass(mgr->cgpassmgr);
+   LLVMAddCoroSplitPass(mgr->cgpassmgr);
+   LLVMAddCoroElidePass(mgr->cgpassmgr);
+#endif
+
+   if ((gallivm_perf & GALLIVM_PERF_NO_OPT) == 0) {
+      /*
+       * TODO: Evaluate passes some more - keeping in mind
+       * both quality of generated code and compile times.
+       */
+      /*
+       * NOTE: if you change this, don't forget to change the output
+       * with GALLIVM_DEBUG_DUMP_BC in gallivm_compile_module.
+       */
+      LLVMAddScalarReplAggregatesPass(mgr->passmgr);
+      LLVMAddEarlyCSEPass(mgr->passmgr);
+      LLVMAddCFGSimplificationPass(mgr->passmgr);
+      /*
+       * FIXME: LICM is potentially quite useful. However, for some
+       * rather crazy shaders the compile time can reach _hours_ per shader,
+       * due to licm implying lcssa (since llvm 3.5), which can take forever.
+       * Even for sane shaders, the cost of licm is rather high (and not just
+       * due to lcssa, licm itself too), though mostly only in cases when it
+       * can actually move things, so having to disable it is a pity.
+       * LLVMAddLICMPass(mgr->passmgr);
+       */
+      LLVMAddReassociatePass(mgr->passmgr);
+      LLVMAddPromoteMemoryToRegisterPass(mgr->passmgr);
+#if LLVM_VERSION_MAJOR <= 11
+      LLVMAddConstantPropagationPass(mgr->passmgr);
+#else
+      LLVMAddInstructionSimplifyPass(mgr->passmgr);
+#endif
+      LLVMAddInstructionCombiningPass(mgr->passmgr);
+      LLVMAddGVNPass(mgr->passmgr);
+   }
+   else {
+      /* We need at least this pass to prevent the backends to fail in
+       * unexpected ways.
+       */
+      LLVMAddPromoteMemoryToRegisterPass(mgr->passmgr);
+   }
+#if HAVE_CORO == 1
+   LLVMAddCoroCleanupPass(mgr->passmgr);
+#endif
+#endif
+   *mgr_p = mgr;
+   return true;
+}
+
+void
+lp_passmgr_run(struct lp_passmgr *mgr,
+               LLVMModuleRef module,
+               LLVMTargetMachineRef tm,
+               const char *module_name)
+{
+   int64_t time_begin;
+
+   if (gallivm_debug & GALLIVM_DEBUG_PERF)
+      time_begin = os_time_get();
+
+#if USE_NEW_PASS == 1
+   char passes[1024];
+   passes[0] = 0;
+
+   /*
+    * there should be some way to combine these two pass runs but I'm not seeing it,
+    * at the time of writing.
+    */
+   strcpy(passes, "default<O0>");
+
+   LLVMPassBuilderOptionsRef opts = LLVMCreatePassBuilderOptions();
+   LLVMRunPasses(module, passes, tm, opts);
+
+   if (!(gallivm_perf & GALLIVM_PERF_NO_OPT))
+#if LLVM_VERSION_MAJOR >= 18
+      strcpy(passes, "sroa,early-cse,simplifycfg,reassociate,mem2reg,instsimplify,instcombine<no-verify-fixpoint>");
+#else
+      strcpy(passes, "sroa,early-cse,simplifycfg,reassociate,mem2reg,instsimplify,instcombine");
+#endif
+   else
+      strcpy(passes, "mem2reg");
+
+   LLVMRunPasses(module, passes, tm, opts);
+   LLVMDisposePassBuilderOptions(opts);
+#else
+#if HAVE_CORO == 1
+   LLVMRunPassManager(mgr->cgpassmgr, module);
+#endif
+   /* Run optimization passes */
+   LLVMInitializeFunctionPassManager(mgr->passmgr);
+   LLVMValueRef func;
+   func = LLVMGetFirstFunction(module);
+   while (func) {
+      if (0) {
+         debug_printf("optimizing func %s...\n", LLVMGetValueName(func));
+      }
+
+   /* Disable frame pointer omission on debug/profile builds */
+   /* XXX: And workaround http://llvm.org/PR21435 */
+#if MESA_DEBUG || defined(PROFILE) || DETECT_ARCH_X86 || DETECT_ARCH_X86_64
+      LLVMAddTargetDependentFunctionAttr(func, "no-frame-pointer-elim", "true");
+      LLVMAddTargetDependentFunctionAttr(func, "no-frame-pointer-elim-non-leaf", "true");
+#endif
+
+      LLVMRunFunctionPassManager(mgr->passmgr, func);
+      func = LLVMGetNextFunction(func);
+   }
+   LLVMFinalizeFunctionPassManager(mgr->passmgr);
+#endif
+   if (gallivm_debug & GALLIVM_DEBUG_PERF) {
+      int64_t time_end = os_time_get();
+      int time_msec = (int)((time_end - time_begin) / 1000);
+      assert(module_name);
+      debug_printf("optimizing module %s took %d msec\n",
+                   module_name, time_msec);
+   }
+}
+
+void
+lp_passmgr_dispose(struct lp_passmgr *mgr)
+{
+#if USE_NEW_PASS == 0
+   if (mgr->passmgr) {
+      LLVMDisposePassManager(mgr->passmgr);
+      mgr->passmgr = NULL;
+   }
+
+#if HAVE_CORO == 1
+   if (mgr->cgpassmgr) {
+      LLVMDisposePassManager(mgr->cgpassmgr);
+      mgr->cgpassmgr = NULL;
+   }
+#endif
+   FREE(mgr);
+#endif
+}
diff --git a/src/gallium/auxiliary/gallivm/lp_bld_passmgr.h b/src/gallium/auxiliary/gallivm/lp_bld_passmgr.h
new file mode 100644
index 00000000000..4ebf6149117
--- /dev/null
+++ b/src/gallium/auxiliary/gallivm/lp_bld_passmgr.h
@@ -0,0 +1,55 @@
+/**************************************************************************
+ *
+ * Copyright 2009 VMware, Inc.
+ * All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sub license, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the
+ * next paragraph) shall be included in all copies or substantial portions
+ * of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+ * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.
+ * IN NO EVENT SHALL VMWARE AND/OR ITS SUPPLIERS BE LIABLE FOR
+ * ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
+ * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
+ * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ *
+ **************************************************************************/
+
+#ifndef LP_BLD_PASSMGR_H
+#define LP_BLD_PASSMGR_H
+
+#include "lp_bld.h"
+#include <llvm-c/ExecutionEngine.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+struct lp_passmgr;
+
+/*
+ * mgr can be returned as NULL for modern pass mgr handling
+ * so use a bool to denote success/fail.
+ */
+bool lp_passmgr_create(LLVMModuleRef module, struct lp_passmgr **mgr);
+void lp_passmgr_run(struct lp_passmgr *mgr,
+                    LLVMModuleRef module,
+                    LLVMTargetMachineRef tm,
+                    const char *module_name);
+void lp_passmgr_dispose(struct lp_passmgr *mgr);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff --git a/src/gallium/auxiliary/meson.build b/src/gallium/auxiliary/meson.build
index a67f71ef35a..0f23a7889db 100644
--- a/src/gallium/auxiliary/meson.build
+++ b/src/gallium/auxiliary/meson.build
@@ -367,6 +367,8 @@ if draw_with_llvm
     'gallivm/lp_bld_nir_soa.c',
     'gallivm/lp_bld_pack.c',
     'gallivm/lp_bld_pack.h',
+    'gallivm/lp_bld_passmgr.h',
+    'gallivm/lp_bld_passmgr.c',
     'gallivm/lp_bld_printf.c',
     'gallivm/lp_bld_printf.h',
     'gallivm/lp_bld_quad.c',
-- 
2.46.0


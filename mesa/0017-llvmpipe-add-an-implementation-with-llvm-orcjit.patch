From f41fdd85fb2f9a9c9a924f5d5cb895c30bcc72c1 Mon Sep 17 00:00:00 2001
From: Yukari Chiba <i@0x7f.cc>
Date: Tue, 25 Jun 2024 13:50:51 +0800
Subject: [PATCH 17/26] llvmpipe: add an implementation with llvm orcjit

Signed-off-by: Icenowy Zheng <uwu@icenowy.me>
---
 meson.build                                   |    4 +-
 meson.build.orig                              | 2437 +++++++++++++++++
 meson_options.txt                             |    7 +
 src/gallium/auxiliary/gallivm/lp_bld.h        |   20 +
 src/gallium/auxiliary/gallivm/lp_bld_coro.c   |    2 +
 src/gallium/auxiliary/gallivm/lp_bld_init.h   |   18 +-
 .../auxiliary/gallivm/lp_bld_init_orc.cpp     |  586 ++++
 src/gallium/auxiliary/meson.build             |    6 +-
 src/gallium/drivers/llvmpipe/lp_state_cs.c    |    7 +
 src/gallium/drivers/llvmpipe/lp_state_fs.c    |    7 +
 10 files changed, 3089 insertions(+), 5 deletions(-)
 create mode 100644 meson.build.orig
 create mode 100644 src/gallium/auxiliary/gallivm/lp_bld_init_orc.cpp

diff --git a/meson.build b/meson.build
index b4d5e2bc0dc..1e8a9081f27 100644
--- a/meson.build
+++ b/meson.build
@@ -1749,13 +1749,14 @@ if with_clc
   llvm_optional_modules += ['all-targets', 'windowsdriver', 'frontendhlsl', 'frontenddriver']
 endif
 draw_with_llvm = get_option('draw-use-llvm')
+llvm_with_orcjit = get_option('llvm-orcjit')
 if draw_with_llvm
   llvm_modules += 'native'
   # lto is needded with LLVM>=15, but we don't know what LLVM verrsion we are using yet
   llvm_optional_modules += ['lto']
 endif
 
-if with_amd_vk or with_gallium_radeonsi or with_clc
+if with_amd_vk or with_gallium_radeonsi or with_clc or llvm_with_orcjit
   _llvm_version = '>= 15.0.0'
 elif with_gallium_opencl
   _llvm_version = '>= 11.0.0'
@@ -1835,6 +1836,7 @@ else
 endif
 pre_args += '-DLLVM_AVAILABLE=' + (with_llvm ? '1' : '0')
 pre_args += '-DDRAW_LLVM_AVAILABLE=' + (with_llvm and draw_with_llvm ? '1' : '0')
+pre_args += '-DGALLIVM_USE_ORCJIT=' + (with_llvm and llvm_with_orcjit ? '1' : '0')
 
 if with_clover_spirv or with_clc
   chosen_llvm_version_array = dep_llvm.version().split('.')
diff --git a/meson.build.orig b/meson.build.orig
new file mode 100644
index 00000000000..1f676a4f3fc
--- /dev/null
+++ b/meson.build.orig
@@ -0,0 +1,2437 @@
+# Copyright Â© 2017-2020 Intel Corporation
+
+# Permission is hereby granted, free of charge, to any person obtaining a copy
+# of this software and associated documentation files (the "Software"), to deal
+# in the Software without restriction, including without limitation the rights
+# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+# copies of the Software, and to permit persons to whom the Software is
+# furnished to do so, subject to the following conditions:
+
+# The above copyright notice and this permission notice shall be included in
+# all copies or substantial portions of the Software.
+
+# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+# SOFTWARE.
+
+project(
+  'mesa',
+  ['c', 'cpp'],
+  version : files('VERSION'),
+  license : 'MIT',
+  meson_version : '>= 1.1.0',
+  default_options : [
+    'buildtype=debugoptimized',
+    'b_ndebug=if-release',
+    'c_std=c11',
+    'cpp_std=c++17',
+    'rust_std=2021',
+    'build.rust_std=2021',
+  ],
+)
+
+cc = meson.get_compiler('c')
+cpp = meson.get_compiler('cpp')
+
+sizeof_pointer = cc.sizeof('void*').to_string()
+
+null_dep = dependency('', required : false)
+
+if get_option('layout') != 'mirror'
+  error('`mirror` is the only build directory layout supported')
+endif
+
+with_mesa_debug = get_option('buildtype') == 'debug'
+
+# This means the final value of b_ndebug==true
+with_mesa_ndebug = get_option('b_ndebug') == 'true' or (get_option('buildtype') == 'release' and get_option('b_ndebug') == 'if-release')
+
+# Arguments for the preprocessor, put these in a separate array from the C and
+# C++ (cpp in meson terminology) arguments since they need to be added to the
+# default arguments for both C and C++.
+pre_args = [
+  '-D__STDC_CONSTANT_MACROS',
+  '-D__STDC_FORMAT_MACROS',
+  '-D__STDC_LIMIT_MACROS',
+  '-DPACKAGE_VERSION="@0@"'.format(meson.project_version()),
+  '-DPACKAGE_BUGREPORT="https://gitlab.freedesktop.org/mesa/mesa/-/issues"',
+]
+# Arguments for c or cpp compiler, can be compiler options
+c_cpp_args = []
+
+c_args = []
+cpp_args = []
+
+with_moltenvk_dir = get_option('moltenvk-dir')
+with_vulkan_icd_dir = get_option('vulkan-icd-dir')
+with_tests = get_option('build-tests')
+with_glcpp_tests = get_option('enable-glcpp-tests')
+with_aco_tests = get_option('build-aco-tests')
+with_glx_read_only_text = get_option('glx-read-only-text')
+with_glx_direct = get_option('glx-direct')
+with_osmesa = get_option('osmesa')
+with_vulkan_overlay_layer = get_option('vulkan-layers').contains('overlay')
+with_vulkan_device_select_layer = get_option('vulkan-layers').contains('device-select')
+with_tools = get_option('tools')
+if with_tools.contains('all')
+  with_tools = [
+    'drm-shim',
+    'dlclose-skip',
+    'etnaviv',
+    'freedreno',
+    'glsl',
+    'intel',
+    'intel-ui',
+    'lima',
+    'nir',
+    'nouveau',
+    'asahi',
+    'imagination',
+  ]
+endif
+
+with_any_vulkan_layers = get_option('vulkan-layers').length() != 0
+with_intel_tools = with_tools.contains('intel') or with_tools.contains('intel-ui')
+with_imgui = with_intel_tools or with_vulkan_overlay_layer
+
+dri_drivers_path = get_option('dri-drivers-path')
+if dri_drivers_path == ''
+  dri_drivers_path = join_paths(get_option('prefix'), get_option('libdir'), 'dri')
+endif
+dri_search_path = get_option('dri-search-path')
+if dri_search_path == ''
+  dri_search_path = dri_drivers_path
+endif
+
+gbm_backends_path = get_option('gbm-backends-path')
+if gbm_backends_path == ''
+  gbm_backends_path = join_paths(get_option('prefix'), get_option('libdir'), 'gbm')
+endif
+
+# Default shared glapi disabled for windows, enabled elsewhere.
+with_shared_glapi = get_option('shared-glapi') \
+  .disable_auto_if(host_machine.system() == 'windows') \
+  .allowed()
+
+with_opengl = get_option('opengl')
+
+with_gles1 = get_option('gles1') \
+  .require(with_shared_glapi, error_message : 'OpengGL ES 1.x requires shared-glapi') \
+  .allowed()
+
+with_gles2 = get_option('gles2') \
+  .require(with_shared_glapi, error_message : 'OpengGL ES 2.x requires shared-glapi') \
+  .allowed()
+
+pre_args += '-DHAVE_OPENGL=@0@'.format(with_opengl ? '1' : '0')
+pre_args += '-DHAVE_OPENGL_ES_1=@0@'.format(with_gles1 ? '1' : '0')
+pre_args += '-DHAVE_OPENGL_ES_2=@0@'.format(with_gles2 ? '1' : '0')
+
+with_any_opengl = with_opengl or with_gles1 or with_gles2
+# Only build shared_glapi if at least one OpenGL API is enabled
+with_shared_glapi = with_shared_glapi and with_any_opengl
+
+system_has_kms_drm = ['openbsd', 'netbsd', 'freebsd', 'gnu/kfreebsd', 'dragonfly', 'linux', 'sunos', 'android', 'managarm'].contains(host_machine.system())
+
+gallium_drivers = get_option('gallium-drivers')
+if gallium_drivers.contains('auto')
+  if system_has_kms_drm
+    # TODO: Sparc
+    if ['x86', 'x86_64'].contains(host_machine.cpu_family())
+      gallium_drivers = [
+        'r300', 'r600', 'radeonsi', 'nouveau', 'virgl', 'svga', 'swrast',
+        'iris', 'crocus', 'i915', 'zink', 'etnaviv'
+      ]
+    elif ['arm', 'aarch64'].contains(host_machine.cpu_family())
+      gallium_drivers = [
+        'v3d', 'vc4', 'freedreno', 'etnaviv', 'nouveau', 'svga',
+        'tegra', 'virgl', 'lima', 'panfrost', 'swrast', 'iris',
+        'zink', 'r300', 'r600', 'radeonsi', 'svga', 'asahi'
+      ]
+    elif ['mips', 'mips64', 'ppc', 'ppc64', 'riscv32', 'riscv64'].contains(host_machine.cpu_family())
+      gallium_drivers = [
+        'r300', 'r600', 'radeonsi', 'nouveau', 'virgl', 'swrast', 'iris',
+        'zink', 'etnaviv'
+      ]
+    elif ['loongarch64'].contains(host_machine.cpu_family())
+      gallium_drivers = [
+        'r300', 'r600', 'radeonsi', 'nouveau', 'virgl', 'etnaviv', 'swrast',
+        'iris', 'zink'
+      ]
+    else
+      error('Unknown architecture @0@. Please pass -Dgallium-drivers to set driver options. Patches gladly accepted to fix this.'.format(
+            host_machine.cpu_family()))
+    endif
+  elif ['windows'].contains(host_machine.system())
+    gallium_drivers = ['swrast', 'zink', 'd3d12']
+  elif ['darwin', 'cygwin', 'haiku'].contains(host_machine.system())
+    gallium_drivers = ['swrast']
+  else
+    error('Unknown OS @0@. Please pass -Dgallium-drivers to set driver options. Patches gladly accepted to fix this.'.format(
+          host_machine.system()))
+  endif
+elif gallium_drivers.contains('all')
+   # Build-test everything except for i915, which depends on libdrm-intel which
+   # is not available on non-Intel distros.
+   gallium_drivers = [
+     'r300', 'r600', 'radeonsi', 'crocus', 'v3d', 'vc4', 'freedreno', 'etnaviv',
+     'nouveau', 'svga', 'tegra', 'virgl', 'lima', 'panfrost', 'swrast', 'iris',
+     'zink', 'd3d12', 'asahi'
+   ]
+endif
+
+with_gallium_radeonsi = gallium_drivers.contains('radeonsi')
+with_gallium_r300 = gallium_drivers.contains('r300')
+with_gallium_r600 = gallium_drivers.contains('r600')
+with_gallium_nouveau = gallium_drivers.contains('nouveau')
+with_gallium_freedreno = gallium_drivers.contains('freedreno')
+with_gallium_softpipe = gallium_drivers.contains('swrast')
+with_gallium_vc4 = gallium_drivers.contains('vc4')
+with_gallium_v3d = gallium_drivers.contains('v3d')
+with_gallium_panfrost = gallium_drivers.contains('panfrost')
+with_gallium_etnaviv = gallium_drivers.contains('etnaviv')
+with_gallium_tegra = gallium_drivers.contains('tegra')
+with_gallium_crocus = gallium_drivers.contains('crocus')
+with_gallium_iris = gallium_drivers.contains('iris')
+with_gallium_i915 = gallium_drivers.contains('i915')
+with_gallium_svga = gallium_drivers.contains('svga')
+with_gallium_virgl = gallium_drivers.contains('virgl')
+with_gallium_lima = gallium_drivers.contains('lima')
+with_gallium_zink = gallium_drivers.contains('zink')
+with_gallium_d3d12 = gallium_drivers.contains('d3d12')
+with_gallium_asahi = gallium_drivers.contains('asahi')
+foreach gallium_driver : gallium_drivers
+  pre_args += '-DHAVE_@0@'.format(gallium_driver.to_upper())
+endforeach
+
+with_gallium = gallium_drivers.length() != 0
+with_gallium_kmsro = system_has_kms_drm and [
+  with_gallium_asahi,
+  with_gallium_etnaviv,
+  with_gallium_freedreno,
+  with_gallium_lima,
+  with_gallium_panfrost,
+  with_gallium_v3d,
+  with_gallium_vc4,
+].contains(true)
+
+_vulkan_drivers = get_option('vulkan-drivers')
+if _vulkan_drivers.contains('auto')
+  if system_has_kms_drm
+    if host_machine.cpu_family().startswith('x86')
+      _vulkan_drivers = [
+        'amd', 'intel', 'intel_hasvk', 'nouveau', 'swrast', 'virtio'
+      ]
+    elif ['arm', 'aarch64'].contains(host_machine.cpu_family())
+      _vulkan_drivers = [
+        'amd', 'broadcom', 'freedreno', 'intel', 'nouveau', 'panfrost',
+        'swrast', 'virtio'
+      ]
+    elif ['mips', 'mips64', 'ppc', 'ppc64', 'riscv32', 'riscv64'].contains(host_machine.cpu_family())
+      _vulkan_drivers = [
+        'amd', 'intel', 'nouveau', 'swrast', 'virtio'
+      ]
+    elif ['loongarch64'].contains(host_machine.cpu_family())
+      _vulkan_drivers = [
+        'amd', 'intel', 'nouveau', 'swrast', 'virtio'
+      ]
+    else
+      error('Unknown architecture @0@. Please pass -Dvulkan-drivers to set driver options. Patches gladly accepted to fix this.'.format(
+            host_machine.cpu_family()))
+    endif
+  elif ['darwin', 'windows', 'cygwin', 'haiku'].contains(host_machine.system())
+    # No vulkan driver supports windows or macOS currently
+    _vulkan_drivers = []
+  else
+    error('Unknown OS @0@. Please pass -Dvulkan-drivers to set driver options. Patches gladly accepted to fix this.'.format(
+          host_machine.system()))
+  endif
+elif _vulkan_drivers.contains('all')
+   # Build every vulkan driver regardless of architecture.
+   _vulkan_drivers = ['amd', 'intel', 'intel_hasvk', 'swrast',
+                      'freedreno', 'panfrost', 'virtio', 'broadcom',
+                      'imagination-experimental', 'microsoft-experimental',
+                      'nouveau']
+endif
+
+with_intel_vk = _vulkan_drivers.contains('intel')
+with_intel_hasvk = _vulkan_drivers.contains('intel_hasvk')
+with_amd_vk = _vulkan_drivers.contains('amd')
+with_freedreno_vk = _vulkan_drivers.contains('freedreno')
+with_panfrost_vk = _vulkan_drivers.contains('panfrost')
+with_swrast_vk = _vulkan_drivers.contains('swrast')
+with_virtio_vk = _vulkan_drivers.contains('virtio')
+with_broadcom_vk = _vulkan_drivers.contains('broadcom')
+with_imagination_vk = _vulkan_drivers.contains('imagination-experimental')
+with_imagination_srv = get_option('imagination-srv')
+with_microsoft_vk = _vulkan_drivers.contains('microsoft-experimental')
+with_nouveau_vk = _vulkan_drivers.contains('nouveau')
+with_any_vk = _vulkan_drivers.length() != 0
+
+if with_any_vk and host_machine.system() == 'windows' and meson.version().version_compare('< 1.3')
+  error('Vulkan drivers on Windows require meson 1.3 or newer')
+endif
+
+freedreno_kmds = get_option('freedreno-kmds')
+if freedreno_kmds.length() != 0 and freedreno_kmds != [ 'msm' ] and with_freedreno_vk
+  if freedreno_kmds.contains('msm')
+      warning('Turnip with the DRM KMD will require libdrm to always be present at runtime which may not always be the case on platforms such as Android.')
+  elif with_gallium_kmsro
+      warning('As a side-effect, Turnip is forced to link with libdrm when built alongside Gallium DRM drivers which platforms such as Android may not have available at runtime.')
+  elif _vulkan_drivers != [ 'freedreno' ]
+      warning('Turnip is forced to link with libdrm when built alongside other Vulkan drivers which platforms such as Android may not have available at runtime.')
+  else
+    # If DRM support isn't needed, we can get rid of it since linking
+    # to libdrm can be a potential compatibility hazard.
+    system_has_kms_drm = false
+  endif
+endif
+
+with_dri = false
+if with_gallium and system_has_kms_drm
+  _glx = get_option('glx')
+  _egl = get_option('egl')
+  if _glx == 'dri' or _egl.enabled() or (_glx == 'disabled' and _egl.allowed())
+    with_dri = true
+  endif
+endif
+
+with_any_broadcom = [
+  with_gallium_vc4,
+  with_gallium_v3d,
+  with_broadcom_vk,
+].contains(true)
+
+if get_option('intel-clc') != 'system'
+  # Require intel-clc with Anv & Iris (for internal shaders)
+  with_intel_clc = get_option('intel-clc') == 'enabled' or \
+                   with_intel_vk or with_gallium_iris
+else
+  with_intel_clc = false
+endif
+
+with_intel_vk_rt = get_option('intel-rt') \
+  .disable_auto_if(not with_intel_vk) \
+  .disable_if(host_machine.cpu_family() != 'x86_64', error_message : 'Intel Ray Tracing is only supported on x86_64') \
+  .allowed()
+
+with_any_intel = [
+  with_gallium_crocus,
+  with_gallium_i915,
+  with_gallium_iris,
+  with_intel_clc,
+  with_intel_hasvk,
+  with_intel_tools,
+  with_intel_vk,
+].contains(true)
+with_any_nouveau = with_gallium_nouveau or with_nouveau_vk
+
+# needed in the loader
+if with_nouveau_vk
+  pre_args += '-DHAVE_NVK'
+endif
+
+if with_swrast_vk and not with_gallium_softpipe
+  error('swrast vulkan requires gallium swrast')
+endif
+if with_gallium_tegra and not with_gallium_nouveau
+  error('tegra driver requires nouveau driver')
+endif
+if with_aco_tests and not with_amd_vk
+  error('ACO tests require Radv')
+endif
+
+with_microsoft_clc = get_option('microsoft-clc').enabled()
+with_spirv_to_dxil = get_option('spirv-to-dxil')
+
+if host_machine.system() == 'darwin'
+  with_dri_platform = 'apple'
+  pre_args += '-DBUILDING_MESA'
+elif ['windows', 'cygwin'].contains(host_machine.system())
+  with_dri_platform = 'windows'
+elif system_has_kms_drm
+  with_dri_platform = 'drm'
+else
+  # FIXME: haiku doesn't use dri, and xlib doesn't use dri, probably should
+  # assert here that one of those cases has been met.
+  # FIXME: illumos ends up here as well
+  with_dri_platform = 'none'
+endif
+
+with_vulkan_beta = get_option('vulkan-beta')
+if host_machine.system() == 'darwin'
+  #macOS seems to need beta extensions to build for now:
+  with_vulkan_beta = true
+endif
+if with_vulkan_beta
+  pre_args += '-DVK_ENABLE_BETA_EXTENSIONS'
+endif
+
+_codecs = get_option('video-codecs')
+patent_codecs = ['vc1dec', 'h264dec', 'h264enc', 'h265dec', 'h265enc']
+free_codecs = ['av1dec', 'av1enc', 'vp9dec']
+all_codecs = patent_codecs + free_codecs
+
+if _codecs.contains('all')
+  _codecs = all_codecs
+elif _codecs.contains('all_free')
+  selected_codecs = _codecs
+  _codecs = free_codecs
+  foreach c : patent_codecs
+    if selected_codecs.contains(c)
+      _codecs += c
+    endif
+  endforeach
+endif
+foreach c : all_codecs
+   pre_args += '-DVIDEO_CODEC_@0@=@1@'.format(c.to_upper(), _codecs.contains(c).to_int())
+endforeach
+
+_platforms = get_option('platforms')
+if _platforms.contains('auto')
+  if system_has_kms_drm
+    _platforms = ['x11', 'wayland']
+  elif ['darwin', 'cygwin'].contains(host_machine.system())
+    _platforms = ['x11']
+  elif ['haiku'].contains(host_machine.system())
+    _platforms = ['haiku']
+  elif host_machine.system() == 'windows'
+    _platforms = ['windows']
+  else
+    error('Unknown OS @0@. Please pass -Dplatforms to set platforms. Patches gladly accepted to fix this.'.format(
+          host_machine.system()))
+  endif
+endif
+
+with_platform_android = _platforms.contains('android')
+with_platform_x11 = _platforms.contains('x11')
+with_platform_wayland = _platforms.contains('wayland')
+with_platform_haiku = _platforms.contains('haiku')
+with_platform_windows = _platforms.contains('windows')
+
+with_glx = get_option('glx')
+if with_glx == 'auto'
+  if not with_opengl
+    with_glx = 'disabled'
+  elif with_platform_android
+    with_glx = 'disabled'
+  elif with_dri
+    with_glx = 'dri'
+  elif with_platform_haiku
+    with_glx = 'disabled'
+  elif host_machine.system() == 'windows'
+    with_glx = 'disabled'
+  elif with_gallium
+    # Even when building just gallium drivers the user probably wants dri
+    with_glx = 'dri'
+  elif with_platform_x11 and with_any_opengl and not with_any_vk
+    # The automatic behavior should not be to turn on xlib based glx when
+    # building only vulkan drivers
+    with_glx = 'xlib'
+  else
+    with_glx = 'disabled'
+  endif
+endif
+if with_glx == 'dri'
+   if with_gallium
+      with_dri = true
+   endif
+endif
+
+if not with_opengl and with_glx != 'disabled'
+  error('Building GLX without OpenGL is not supported.') \
+endif
+
+if not (with_dri or with_gallium or with_glx != 'disabled')
+  with_gles1 = false
+  with_gles2 = false
+  with_opengl = false
+  with_any_opengl = false
+  with_shared_glapi = false
+endif
+
+with_gbm = get_option('gbm') \
+  .require(system_has_kms_drm, error_message : 'GBM only supports DRM/KMS platforms') \
+  .disable_auto_if(not with_dri) \
+  .allowed()
+
+with_xlib_lease = get_option('xlib-lease') \
+  .require(with_platform_x11 and (system_has_kms_drm or with_dri_platform == 'apple'), error_message : 'xlib-lease requires X11 and KMS/DRM support') \
+  .allowed()
+
+with_egl = get_option('egl') \
+  .require(with_platform_windows or with_platform_haiku or with_dri or with_platform_android, error_message : 'EGL requires DRI, Haiku, Windows or Android') \
+  .require(with_shared_glapi, error_message : 'EGL requires shared-glapi') \
+  .require(with_glx != 'xlib', error_message :'EGL requires DRI, but GLX is being built with xlib support') \
+  .disable_auto_if(with_platform_haiku) \
+  .allowed()
+
+if with_egl
+  _platforms += 'surfaceless'
+  if with_gbm and not with_platform_android
+    _platforms += 'drm'
+  endif
+
+  egl_native_platform = get_option('egl-native-platform')
+  if egl_native_platform.contains('auto')
+    egl_native_platform = _platforms[0]
+  endif
+endif
+
+if with_egl and not _platforms.contains(egl_native_platform)
+  error('-Degl-native-platform does not specify an enabled platform')
+endif
+
+if 'x11' in _platforms
+  _platforms += 'xcb'
+endif
+
+foreach platform : _platforms
+  pre_args += '-DHAVE_@0@_PLATFORM'.format(platform.to_upper())
+endforeach
+
+if with_platform_android and get_option('platform-sdk-version') >= 29
+  # By default the NDK compiler, at least, emits emutls references instead of
+  # ELF TLS, even when building targeting newer API levels.  Make it actually do
+  # ELF TLS instead.
+  c_cpp_args += '-fno-emulated-tls'
+endif
+
+# -mtls-dialect=gnu2 speeds up non-initial-exec TLS significantly but requires
+# full toolchain (including libc) support.
+have_mtls_dialect = false
+foreach c_arg : get_option('c_args')
+  if c_arg.startswith('-mtls-dialect=')
+    have_mtls_dialect = true
+    break
+  endif
+endforeach
+if not have_mtls_dialect
+  # need .run to check libc support. meson aborts when calling .run when
+  # cross-compiling, but because this is just an optimization we can skip it
+  if meson.is_cross_build() and not meson.can_run_host_binaries()
+    warning('cannot auto-detect -mtls-dialect when cross-compiling, using compiler default')
+  else
+    # -fpic to force dynamic tls, otherwise TLS relaxation defeats check
+    gnu2_test = cc.run('int __thread x; int main() { return x; }',
+                       args: ['-mtls-dialect=gnu2', '-fpic'],
+                       name: '-mtls-dialect=gnu2')
+    if gnu2_test.returncode() == 0 and (
+          # check for lld 13 bug: https://gitlab.freedesktop.org/mesa/mesa/-/issues/5665
+          host_machine.cpu_family() != 'x86_64' or
+          # get_linker_id misses LDFLAGS=-fuse-ld=lld: https://github.com/mesonbuild/meson/issues/6377
+          #cc.get_linker_id() != 'ld.lld' or
+          cc.links('''int __thread x; int y; int main() { __asm__(
+                "leaq x@TLSDESC(%rip), %rax\n"
+                "movq y@GOTPCREL(%rip), %rdx\n"
+                "call *x@TLSCALL(%rax)\n"); }''', name: 'split TLSDESC')
+          )
+      c_cpp_args += '-mtls-dialect=gnu2'
+    endif
+  endif
+endif
+
+if with_glx != 'disabled'
+  if not (with_platform_x11 and with_any_opengl)
+    error('Cannot build GLX support without X11 platform support and at least one OpenGL API')
+  elif with_glx == 'xlib'
+    if not with_gallium
+      error('xlib based GLX requires at least one gallium driver')
+    elif not with_gallium_softpipe
+      error('xlib based GLX requires softpipe or llvmpipe.')
+    elif with_dri
+      error('xlib conflicts with any dri driver')
+    endif
+  elif with_glx == 'dri'
+    if not with_shared_glapi
+      error('dri based GLX requires shared-glapi')
+    endif
+  endif
+endif
+
+_glvnd = get_option('glvnd') \
+  .require(not with_platform_windows,
+           error_message: 'glvnd cannot be used on Windows') \
+  .require(with_glx != 'xlib',
+           error_message: 'Cannot build glvnd support for GLX that is not DRI based.') \
+  .require(with_glx != 'disabled' or with_egl,
+           error_message: 'glvnd requires DRI based GLX and/or EGL') \
+  .require(get_option('egl-lib-suffix') == '',
+           error_message: '''EGL lib suffix can't be used with libglvnd''')
+dep_glvnd = dependency('libglvnd', version : '>= 1.3.2', required : _glvnd)
+with_glvnd = dep_glvnd.found()
+if with_glvnd
+  pre_args += '-DUSE_LIBGLVND=1'
+endif
+glvnd_vendor_name = get_option('glvnd-vendor-name')
+
+if with_vulkan_icd_dir == ''
+  with_vulkan_icd_dir = join_paths(get_option('datadir'), 'vulkan/icd.d')
+endif
+
+# GNU/Hurd includes egl_dri2, without drm.
+with_dri2 = (with_dri or with_any_vk) and (with_dri_platform == 'drm' or with_dri_platform == 'apple' or
+  host_machine.system() == 'gnu')
+with_dri3 = get_option('dri3').disable_auto_if(not (system_has_kms_drm and with_dri2)).allowed()
+
+if with_any_vk and (with_platform_x11 and not with_dri3)
+  error('Vulkan drivers require dri3 for X11 support')
+endif
+if with_dri
+  if with_glx == 'disabled' and not with_egl and not with_gbm
+    error('building dri drivers require at least one windowing system')
+  endif
+endif
+
+if with_gallium_kmsro and (with_platform_x11 and not with_dri3)
+  error('kmsro requires dri3 for X11 support')
+endif
+
+dep_dxheaders = null_dep
+if with_gallium_d3d12 or with_microsoft_clc or with_microsoft_vk
+  dep_dxheaders = dependency('directx-headers', required : false)
+  if not dep_dxheaders.found()
+    dep_dxheaders = dependency('DirectX-Headers',
+      version : '>= 1.613.0',
+      fallback : ['DirectX-Headers', 'dep_dxheaders'],
+      required : with_gallium_d3d12 or with_microsoft_vk
+    )
+  endif
+endif
+
+_with_gallium_d3d12_video = get_option('gallium-d3d12-video')
+with_gallium_d3d12_video = false
+if with_gallium_d3d12 and not _with_gallium_d3d12_video.disabled()
+  with_gallium_d3d12_video = true
+  pre_args += '-DHAVE_GALLIUM_D3D12_VIDEO'
+endif
+
+_vdpau_drivers = [
+  with_gallium_d3d12_video,
+  with_gallium_nouveau,
+  with_gallium_r600,
+  with_gallium_radeonsi,
+  with_gallium_virgl,
+]
+
+vdpau = get_option('gallium-vdpau') \
+  .require(system_has_kms_drm, error_message : 'VDPAU state tracker can only be build on unix-like OSes.') \
+  .require(with_platform_x11, error_message : 'VDPAU state tracker requires X11 support.') \
+  .require(_vdpau_drivers.contains(true), error_message : 'VDPAU state tracker requires at least one of the following gallium drivers: r600, radeonsi, nouveau, d3d12 (with option gallium-d3d12-video, virgl).')
+
+dep_vdpau = dependency('vdpau', version : '>= 1.5', required : vdpau)
+if dep_vdpau.found()
+  dep_vdpau = dep_vdpau.partial_dependency(compile_args : true)
+  pre_args += '-DHAVE_ST_VDPAU'
+endif
+with_gallium_vdpau = dep_vdpau.found()
+
+vdpau_drivers_path = get_option('vdpau-libs-path')
+if vdpau_drivers_path == ''
+  vdpau_drivers_path = join_paths(get_option('libdir'), 'vdpau')
+endif
+
+prog_glslang = find_program('glslangValidator', native : true, required : with_vulkan_overlay_layer or with_aco_tests or with_amd_vk or with_intel_vk)
+if prog_glslang.found()
+  if run_command(prog_glslang, [ '--quiet', '--version' ], check : false).returncode() == 0
+    glslang_quiet = ['--quiet']
+  else
+    glslang_quiet = []
+  endif
+endif
+
+dep_xv = null_dep
+_omx = get_option('gallium-omx')
+if not system_has_kms_drm
+  if ['auto', 'disabled'].contains(_omx)
+    _omx = 'disabled'
+  else
+    error('OMX state tracker can only be built on unix-like OSes.')
+  endif
+elif not (with_gallium_r600 or with_gallium_radeonsi or with_gallium_nouveau)
+  if ['auto', 'disabled'].contains(_omx)
+    _omx = 'disabled'
+  else
+    error('OMX state tracker requires at least one of the following gallium drivers: r600, radeonsi, nouveau.')
+  endif
+endif
+with_gallium_omx = _omx
+dep_omx = null_dep
+dep_omx_other = []
+if ['auto', 'bellagio'].contains(_omx)
+  dep_omx = dependency(
+    'libomxil-bellagio', required : _omx == 'bellagio'
+  )
+  if dep_omx.found()
+    with_gallium_omx = 'bellagio'
+  endif
+endif
+if ['auto', 'tizonia'].contains(_omx)
+  if with_dri and with_egl
+    dep_omx = dependency(
+      'libtizonia', version : '>= 0.10.0',
+      required : _omx == 'tizonia',
+    )
+    dep_omx_other = [
+      dependency('libtizplatform', required : _omx == 'tizonia'),
+      dependency('tizilheaders', required : _omx == 'tizonia'),
+    ]
+    if dep_omx.found() and dep_omx_other[0].found() and dep_omx_other[1].found()
+      with_gallium_omx = 'tizonia'
+    endif
+  elif _omx == 'tizonia'
+    error('OMX-Tizonia state tracker requires dri and egl')
+  endif
+endif
+if _omx == 'auto'
+  with_gallium_omx = 'disabled'
+else
+  with_gallium_omx = _omx
+endif
+
+pre_args += [
+  '-DENABLE_ST_OMX_BELLAGIO=' + (with_gallium_omx == 'bellagio' ? '1' : '0'),
+  '-DENABLE_ST_OMX_TIZONIA=' + (with_gallium_omx == 'tizonia' ? '1' : '0'),
+]
+
+
+omx_drivers_path = get_option('omx-libs-path')
+
+if with_gallium_omx != 'disabled'
+  # Figure out where to put the omx driver.
+  # FIXME: this could all be vastly simplified by adding a 'defined_variable'
+  # argument to meson's get_variable method.
+  if omx_drivers_path == ''
+    _omx_libdir = dep_omx.get_variable(pkgconfig : 'libdir')
+    _omx_drivers_dir = dep_omx.get_variable(pkgconfig : 'pluginsdir')
+    if _omx_libdir == get_option('libdir')
+      omx_drivers_path = _omx_drivers_dir
+    else
+      _omx_base_dir = []
+      # This will fail on windows. Does OMX run on windows?
+      _omx_libdir = _omx_libdir.split('/')
+      _omx_drivers_dir = _omx_drivers_dir.split('/')
+      foreach o : _omx_drivers_dir
+        if not _omx_libdir.contains(o)
+          _omx_base_dir += o
+        endif
+      endforeach
+      omx_drivers_path = join_paths(get_option('libdir'), _omx_base_dir)
+    endif
+  endif
+endif
+
+_va_drivers = [
+  with_gallium_d3d12_video,
+  with_gallium_nouveau,
+  with_gallium_r600,
+  with_gallium_radeonsi,
+  with_gallium_virgl,
+]
+
+_va = get_option('gallium-va') \
+  .require(_va_drivers.contains(true),
+           error_message : 'VA state tracker requires at least one of the following gallium drivers: r600, radeonsi, nouveau, d3d12 (with option gallium-d3d12-video), virgl.')
+_dep_va_name = host_machine.system() == 'windows' ? 'libva-win32' : 'libva'
+dep_va = dependency(_dep_va_name, version : '>= 1.8.0', required : _va)
+if dep_va.found()
+  dep_va_headers = dep_va.partial_dependency(compile_args : true)
+  if cc.has_header_symbol('va/va.h', 'VASurfaceAttribDRMFormatModifiers',
+                          dependencies: dep_va_headers)
+    pre_args += '-DHAVE_VA_SURFACE_ATTRIB_DRM_FORMAT_MODIFIERS'
+  endif
+endif
+with_gallium_va = dep_va.found()
+
+va_drivers_path = get_option('va-libs-path')
+if va_drivers_path == ''
+  va_drivers_path = join_paths(get_option('libdir'), 'dri')
+endif
+
+with_gallium_xa = get_option('gallium-xa') \
+  .require(system_has_kms_drm, error_message : 'XA state tracker can only be built on unix-like OSes.') \
+  .require(with_gallium_nouveau or with_gallium_freedreno or with_gallium_i915 or with_gallium_svga,
+           error_message : 'XA state tracker requires at least one of the following gallium drivers: nouveau, freedreno, i915, svga.') \
+  .allowed()
+
+d3d_drivers_path = get_option('d3d-drivers-path')
+if d3d_drivers_path == ''
+  d3d_drivers_path = join_paths(get_option('prefix'), get_option('libdir'), 'd3d')
+endif
+
+with_gallium_st_nine =  get_option('gallium-nine')
+if with_gallium_st_nine
+  if not with_gallium_softpipe
+    error('The nine state tracker requires gallium softpipe/llvmpipe.')
+  elif not [
+             with_gallium_crocus,
+             with_gallium_freedreno,
+             with_gallium_i915,
+             with_gallium_iris,
+             with_gallium_nouveau,
+             with_gallium_panfrost,
+             with_gallium_r300,
+             with_gallium_r600,
+             with_gallium_radeonsi,
+             with_gallium_svga,
+             with_gallium_zink,
+           ].contains(true)
+    error('The nine state tracker requires at least one non-swrast gallium driver.')
+  endif
+  if not with_dri3
+    error('Using nine with wine requires dri3')
+  endif
+endif
+with_gallium_st_d3d10umd =  get_option('gallium-d3d10umd')
+if with_gallium_st_d3d10umd
+  if not with_gallium_softpipe
+    error('The d3d10umd state tracker requires gallium softpipe/llvmpipe.')
+  endif
+endif
+_power8 = get_option('power8')
+if _power8.allowed()
+  if host_machine.cpu_family() == 'ppc64' and host_machine.endian() == 'little'
+    if cc.get_id() == 'gcc' and cc.version().version_compare('< 4.8')
+      error('Altivec is not supported with gcc version < 4.8.')
+    endif
+    if cc.compiles('''
+        #include <altivec.h>
+        int main() {
+          vector unsigned char r;
+          vector unsigned int v = vec_splat_u32 (1);
+          r = __builtin_vec_vgbbd ((vector unsigned char) v);
+          return 0;
+        }''',
+        args : '-mpower8-vector',
+        name : 'POWER8 intrinsics')
+      pre_args += ['-D_ARCH_PWR8']
+      c_cpp_args += '-mpower8-vector'
+    elif _power8.enabled()
+      error('POWER8 intrinsic support required but not found.')
+    endif
+  endif
+endif
+
+if get_option('vmware-mks-stats')
+  if not with_gallium_svga
+    error('vmware-mks-stats requires gallium VMware/svga driver.')
+  endif
+  pre_args += '-DVMX86_STATS=1'
+endif
+
+_opencl = get_option('gallium-opencl')
+_rtti = get_option('cpp_rtti')
+if _opencl != 'disabled'
+  if not with_gallium
+    error('OpenCL Clover implementation requires at least one gallium driver.')
+  endif
+  if not _rtti
+    error('The Clover OpenCL state tracker requires rtti')
+  endif
+
+  with_gallium_opencl = true
+  with_opencl_icd = _opencl == 'icd'
+else
+  with_gallium_opencl = false
+  with_opencl_icd = false
+endif
+
+with_gallium_rusticl = get_option('gallium-rusticl')
+if with_gallium_rusticl
+  if not with_gallium
+    error('rusticl requires at least one gallium driver.')
+  endif
+
+  if meson.version().version_compare('< 1.3.1')
+    error('rusticl requires meson 1.3.1 or newer')
+  endif
+
+  add_languages('rust', required: true)
+  rustc = meson.get_compiler('rust')
+endif
+
+with_clover_spirv = with_gallium_opencl and get_option('opencl-spirv')
+with_clc = with_microsoft_clc or with_intel_clc or with_gallium_asahi or with_gallium_rusticl or with_clover_spirv
+
+dep_clc = null_dep
+if with_gallium_opencl or with_clc
+  dep_clc = dependency('libclc')
+endif
+
+gl_pkgconfig_c_flags = []
+with_glx_indirect_rendering = false
+if with_platform_x11
+  if with_glx == 'xlib'
+    pre_args += '-DUSE_XSHM'
+  else
+    with_glx_indirect_rendering = true
+    pre_args += '-DGLX_INDIRECT_RENDERING'
+    if with_glx_direct
+      pre_args += '-DGLX_DIRECT_RENDERING'
+    endif
+    if with_dri_platform == 'drm'
+      pre_args += '-DGLX_USE_DRM'
+    elif with_dri_platform == 'apple'
+      pre_args += '-DGLX_USE_APPLEGL'
+      # Check to see if more than just the default 'swrast' is required
+      if (not with_gallium_softpipe) or 1 < gallium_drivers.length()
+        # Switch the MacOS code from "forwarding to the OpenGL.framework" mode
+        # and into actual Gallium Driver mode
+        pre_args += '-DGLX_USE_APPLE'
+      endif
+    elif with_dri_platform == 'windows'
+      pre_args += '-DGLX_USE_WINDOWSGL'
+    endif
+  endif
+endif
+
+with_glapi_export_proto_entry_points = false
+if with_shared_glapi and not with_glx_indirect_rendering
+  # Imply !defined(GLX_INDIRECT_RENDERING)
+  with_glapi_export_proto_entry_points = true
+endif
+pre_args += '-DGLAPI_EXPORT_PROTO_ENTRY_POINTS=@0@'.format(with_glapi_export_proto_entry_points ? '1' : '0')
+
+with_android_stub = get_option('android-stub')
+if with_android_stub and not with_platform_android
+  error('`-D android-stub=true` makes no sense without `-D platforms=android`')
+endif
+
+with_libbacktrace = get_option('android-libbacktrace') \
+  .require(with_platform_android, error_message : '`-D android-libbacktrace=enabled` makes no sense without `-D platforms=android`') \
+  .disable_auto_if(not with_platform_android) \
+  .allowed()
+
+if with_libbacktrace
+  cpp_args += '-DWITH_LIBBACKTRACE'
+endif
+
+if with_platform_android
+  dep_android_mapper4 = null_dep
+  if not with_android_stub
+    dep_android = [
+      dependency('cutils'),
+      dependency('hardware'),
+      dependency('sync'),
+    ]
+    if with_libbacktrace
+      dep_android += dependency('backtrace')
+    endif
+    if get_option('platform-sdk-version') >= 26
+      dep_android += dependency('nativewindow')
+    endif
+    if get_option('platform-sdk-version') >= 30
+      dep_android_mapper4 = dependency('android.hardware.graphics.mapper', version : '>= 4.0', required : false)
+    endif
+  endif
+  pre_args += '-DANDROID_API_LEVEL=' + get_option('platform-sdk-version').to_string()
+  if get_option('android-strict')
+    pre_args += '-DANDROID_STRICT'
+  endif
+endif
+
+# On Android, seccomp kills the process on kernels without
+# CONFIG_KCMP/CONFIG_CHECKPOINT_RESTORE if it attemps to use KCMP.
+# Since we can't detect that, err on the side of caution and disable
+# KCMP by default on Android.
+if get_option('allow-kcmp') \
+    .disable_auto_if(with_platform_android) \
+    .allowed()
+  pre_args += '-DALLOW_KCMP'
+endif
+
+prog_python = import('python').find_installation('python3')
+has_mako = run_command(
+  prog_python, '-c',
+  '''
+try:
+  from packaging.version import Version
+except:
+  from distutils.version import StrictVersion as Version
+import mako
+assert Version(mako.__version__) >= Version("0.8.0")
+  ''', check: false)
+if has_mako.returncode() != 0
+  error('Python (3.x) mako module >= 0.8.0 required to build mesa.')
+endif
+
+if cc.get_id() == 'gcc' and cc.version().version_compare('< 4.4.6')
+  error('When using GCC, version 4.4.6 or later is required.')
+endif
+
+# Support systems without ETIME (e.g. FreeBSD)
+if cc.get_define('ETIME', prefix : '#include <errno.h>') == ''
+  pre_args += '-DETIME=ETIMEDOUT'
+endif
+
+# Define MESA_DEBUG to 1 for debug builds only (debugoptimized is not included on this one);
+# otherwise define MESA_DEBUG to 0
+pre_args += '-DMESA_DEBUG=' + (with_mesa_debug ? '1' : '0')
+
+with_split_debug = get_option('split-debug') \
+  .disable_if(not cc.has_argument('-gsplit-dwarf'),
+    error_message : 'split-debug requires compiler -gsplit-dwarf support') \
+  .disable_if(not cc.has_link_argument('-Wl,--gdb-index'),
+    error_message : 'split-debug requires the linker argument -Wl,--gdb-index')
+
+if with_split_debug.allowed() and get_option('debug')
+  add_project_arguments('-gsplit-dwarf', language : ['c', 'cpp'])
+  add_project_link_arguments('-Wl,--gdb-index', language : ['c', 'cpp'])
+endif
+
+with_shader_cache = get_option('shader-cache') \
+  .require(host_machine.system() != 'windows', error_message : 'Shader Cache does not currently work on Windows') \
+  .allowed()
+
+if with_shader_cache
+  pre_args += '-DENABLE_SHADER_CACHE'
+  if not get_option('shader-cache-default')
+    pre_args += '-DSHADER_CACHE_DISABLE_BY_DEFAULT'
+  endif
+
+  shader_cache_max_size = get_option('shader-cache-max-size')
+  if shader_cache_max_size != ''
+    pre_args += '-DMESA_SHADER_CACHE_MAX_SIZE="@0@"'.format(shader_cache_max_size)
+  endif
+endif
+
+# Check for GCC style builtins
+foreach b : ['bswap32', 'bswap64', 'clz', 'clzll', 'ctz', 'expect', 'ffs',
+             'ffsll', 'popcount', 'popcountll', 'unreachable', 'types_compatible_p']
+  if cc.has_function(b)
+    pre_args += '-DHAVE___BUILTIN_@0@'.format(b.to_upper())
+  endif
+endforeach
+
+# check for GCC __attribute__
+_attributes = [
+  'const', 'flatten', 'malloc', 'pure', 'unused', 'warn_unused_result',
+  'weak', 'format', 'packed', 'returns_nonnull', 'alias', 'noreturn',
+]
+foreach a : cc.get_supported_function_attributes(_attributes)
+  pre_args += '-DHAVE_FUNC_ATTRIBUTE_@0@'.format(a.to_upper())
+endforeach
+if cc.has_function_attribute('visibility:hidden')
+  pre_args += '-DHAVE_FUNC_ATTRIBUTE_VISIBILITY'
+endif
+if cc.compiles('__uint128_t foo(void) { return 0; }',
+               name : '__uint128_t')
+  pre_args += '-DHAVE_UINT128'
+endif
+
+if cc.has_function('reallocarray')
+   pre_args += '-DHAVE_REALLOCARRAY'
+endif
+if cc.has_function('fmemopen')
+   pre_args += '-DHAVE_FMEMOPEN'
+endif
+
+# TODO: this is very incomplete
+if ['linux', 'cygwin', 'gnu', 'freebsd', 'gnu/kfreebsd', 'haiku', 'android', 'managarm'].contains(host_machine.system())
+  pre_args += '-D_GNU_SOURCE'
+elif host_machine.system() == 'sunos'
+  pre_args += '-D__EXTENSIONS__'
+elif host_machine.system() == 'windows'
+  pre_args += [
+    '-D_WINDOWS', '-D_WIN32_WINNT=0x0A00', '-DWINVER=0x0A00',
+    '-DPIPE_SUBSYSTEM_WINDOWS_USER',
+    '-D_USE_MATH_DEFINES',  # XXX: scons didn't use this for mingw
+  ]
+  if cc.get_argument_syntax() == 'msvc'
+    pre_args += [
+      '-DVC_EXTRALEAN',
+      '-D_CRT_SECURE_NO_WARNINGS',
+      '-D_CRT_SECURE_NO_DEPRECATE',
+      '-D_SCL_SECURE_NO_WARNINGS',
+      '-D_SCL_SECURE_NO_DEPRECATE',
+      '-D_ALLOW_KEYWORD_MACROS',
+      '-D_HAS_EXCEPTIONS=0', # Tell C++ STL to not use exceptions
+      '-DNOMINMAX',
+    ]
+  else
+    # When the target is not mingw/ucrt
+    # NOTE: clang's stddef.h are conflict with mingw/ucrt's stddef.h
+    # So do not include headers that defined in clang for detecting
+    # _UCRT
+    if cc.compiles('''
+      #include <string.h>
+      #if defined(__MINGW32__) && defined(_UCRT)
+      #error
+      #endif
+      int main(void) { return 0; }''')
+      pre_args += ['-D__MSVCRT_VERSION__=0x0700']
+    endif
+  endif
+elif host_machine.system() == 'openbsd'
+  pre_args += '-D_ISOC11_SOURCE'
+endif
+
+# Check for generic C arguments
+c_msvc_compat_args = []
+no_override_init_args = []
+cpp_msvc_compat_args = []
+ld_args_gc_sections = []
+if cc.get_argument_syntax() == 'msvc'
+  _trial = [
+    '/wd4018',  # signed/unsigned mismatch
+    '/wd4056',  # overflow in floating-point constant arithmetic
+    '/wd4244',  # conversion from 'type1' to 'type2', possible loss of data
+    '/wd4267',  # 'var' : conversion from 'size_t' to 'type', possible loss of data
+    '/wd4305',  # truncation from 'type1' to 'type2'
+    '/wd4351',  # new behavior: elements of array 'array' will be default initialized
+    '/wd4756',  # overflow in constant arithmetic
+    '/wd4800',  # forcing value to bool 'true' or 'false' (performance warning)
+    '/wd4996',  # disabled deprecated POSIX name warnings
+    '/wd4291',  # no matching operator delete found
+    '/wd4146',  # unary minus operator applied to unsigned type, result still unsigned
+    '/wd4200',  # nonstandard extension used: zero-sized array in struct/union
+    '/wd4624',  # destructor was implicitly defined as deleted [from LLVM]
+    '/wd4309',  # 'initializing': truncation of constant value
+    '/wd4838',  # conversion from 'int' to 'const char' requires a narrowing conversion
+    '/wd5105',  # macro expansion producing 'defined' has undefined behavior (winbase.h, need Windows SDK upgrade)
+    '/we4020',  # Error when passing the wrong number of parameters
+    '/we4024',  # Error when passing different type of parameter
+    '/we4189',  # 'identifier' : local variable is initialized but not referenced
+    '/Zc:__cplusplus', #Set __cplusplus macro to match the /std:c++<version> on the command line
+  ]
+  c_args += cc.get_supported_arguments(_trial)
+  cpp_args += cpp.get_supported_arguments(_trial)
+else
+  _trial_c = [
+    '-Werror=implicit-function-declaration',
+    '-Werror=missing-prototypes',
+    '-Werror=return-type',
+    '-Werror=empty-body',
+    '-Werror=incompatible-pointer-types',
+    '-Werror=int-conversion',
+    '-Wimplicit-fallthrough',
+    '-Wmisleading-indentation',
+    '-Wno-missing-field-initializers',
+    '-Wno-format-truncation',
+    '-Wno-nonnull-compare',
+    '-fno-math-errno',
+    '-fno-trapping-math',
+    '-Qunused-arguments',
+    '-fno-common',
+    '-Wno-unknown-pragmas',
+    # Clang
+    '-Wno-microsoft-enum-value',
+    '-Wno-unused-function',
+  ]
+  _trial_cpp = [
+    '-Werror=return-type',
+    '-Werror=empty-body',
+    '-Wmisleading-indentation',
+    '-Wno-non-virtual-dtor',
+    '-Wno-missing-field-initializers',
+    '-Wno-format-truncation',
+    '-fno-math-errno',
+    '-fno-trapping-math',
+    '-Qunused-arguments',
+    # Some classes use custom new operator which zeroes memory, however
+    # gcc does aggressive dead-store elimination which threats all writes
+    # to the memory before the constructor as "dead stores".
+    # For now we disable this optimization.
+    '-flifetime-dse=1',
+    '-Wno-unknown-pragmas',
+    # Clang
+    '-Wno-microsoft-enum-value',
+  ]
+
+  # MinGW chokes on format specifiers and I can't get it all working
+  if not (cc.get_argument_syntax() == 'gcc' and host_machine.system() == 'windows')
+    _trial_c += ['-Werror=format', '-Wformat-security']
+    _trial_cpp += ['-Werror=format', '-Wformat-security']
+  endif
+
+  # FreeBSD annotated <pthread.h> but Mesa isn't ready
+  if not (cc.get_id() == 'clang' and host_machine.system() == 'freebsd')
+    _trial_c += ['-Werror=thread-safety']
+  endif
+
+  # If the compiler supports it, put function and data symbols in their
+  # own sections and GC the sections after linking.  This lets drivers
+  # drop shared code unused by that specific driver (particularly
+  # relevant for Vulkan drivers).
+  if cc.links('static char unused() { return 5; } int main() { return 0; }',
+              args : '-Wl,--gc-sections', name : 'gc-sections')
+    ld_args_gc_sections += '-Wl,--gc-sections'
+    _trial_c += ['-ffunction-sections', '-fdata-sections']
+    _trial_cpp += ['-ffunction-sections', '-fdata-sections']
+  endif
+
+  # Variables that are only used for assertions are considered unused when assertions
+  # are disabled. Don't treat this as an error, since we build with -Werror even if
+  # assertions are disabled.
+  if with_mesa_ndebug
+    _trial_c += ['-Wno-unused-variable', '-Wno-unused-but-set-variable', '/wd4189']
+    _trial_cpp += ['-Wno-unused-variable', '-Wno-unused-but-set-variable', '/wd4189']
+  endif
+
+  c_args += cc.get_supported_arguments(_trial_c)
+  cpp_args += cpp.get_supported_arguments(_trial_cpp)
+
+  no_override_init_args += cc.get_supported_arguments(
+    ['-Wno-override-init', '-Wno-initializer-overrides']
+  )
+
+  # Check for C and C++ arguments for MSVC compatibility. These are only used
+  # in parts of the mesa code base that need to compile with MSVC, mainly
+  # common code
+  _trial_msvc = ['-Werror=pointer-arith', '-Werror=vla', '-Werror=gnu-empty-initializer']
+  c_msvc_compat_args += cc.get_supported_arguments(_trial_msvc)
+  cpp_msvc_compat_args += cpp.get_supported_arguments(_trial_msvc)
+endif
+
+# set linker arguments
+if host_machine.system() == 'windows'
+  if cc.get_argument_syntax() == 'msvc'
+    add_project_link_arguments(
+      '/fixed:no',
+      '/dynamicbase',
+      '/nxcompat',
+      language : ['c', 'cpp'],
+    )
+    if get_option('buildtype') != 'debug'
+      add_project_link_arguments(
+        '/incremental:no',
+        language : ['c', 'cpp'],
+      )
+    endif
+  else
+    add_project_link_arguments(
+      cc.get_supported_link_arguments(
+        '-Wl,--nxcompat',
+        '-Wl,--dynamicbase',
+        '-static-libgcc',
+        '-static-libstdc++',
+      ),
+      language : ['c'],
+    )
+    add_project_link_arguments(
+      cpp.get_supported_link_arguments(
+        '-Wl,--nxcompat',
+        '-Wl,--dynamicbase',
+        '-static-libgcc',
+        '-static-libstdc++',
+      ),
+      language : ['cpp'],
+    )
+  endif
+endif
+
+sse2_arg = []
+sse2_args = []
+sse41_args = []
+with_sse41 = false
+if host_machine.cpu_family().startswith('x86')
+  pre_args += '-DUSE_SSE41'
+  with_sse41 = true
+
+  if cc.get_id() != 'msvc'
+    sse41_args = ['-msse4.1']
+
+    if host_machine.cpu_family() == 'x86'
+      # x86_64 have sse2 by default, so sse2 args only for x86
+      sse2_arg = ['-msse2', '-mfpmath=sse']
+      sse2_args = [sse2_arg, '-mstackrealign']
+      if get_option('sse2')
+        # These settings make generated GCC code match MSVC and follow
+        # GCC advice on https://gcc.gnu.org/wiki/FloatingPointMath#x86note
+        #
+        # NOTE: We need to ensure stack is realigned given that we
+        # produce shared objects, and have no control over the stack
+        # alignment policy of the application. Therefore we need
+        # -mstackrealign or -mincoming-stack-boundary=2.
+        #
+        # XXX: We could have SSE without -mstackrealign if we always used
+        # __attribute__((force_align_arg_pointer)), but that's not
+        # always the case.
+        c_cpp_args += sse2_args
+        # sse2_args are adopted into c_cpp_args to avoid duplicated sse2 command line args
+        sse2_arg = []
+        sse2_args = []
+      else
+        # GCC on x86 (not x86_64) with -msse* assumes a 16 byte aligned stack, but
+        # that's not guaranteed
+        sse41_args += '-mstackrealign'
+      endif
+    endif
+  endif
+endif
+
+# Detect __builtin_ia32_clflushopt support
+if cc.has_function('__builtin_ia32_clflushopt', args : '-mclflushopt')
+  pre_args += '-DHAVE___BUILTIN_IA32_CLFLUSHOPT'
+  clflushopt_args = ['-mclflushopt']
+  with_clflushopt = true
+else
+  clflushopt_args = []
+  with_clflushopt = false
+endif
+
+# Check for GCC style atomics
+dep_atomic = null_dep
+
+if cc.compiles('''#include <stdint.h>
+                  int main() {
+                    struct {
+                      uint64_t *v;
+                    } x;
+                    return (int)__atomic_load_n(x.v, __ATOMIC_ACQUIRE) &
+                           (int)__atomic_add_fetch(x.v, (uint64_t)1, __ATOMIC_ACQ_REL);
+
+                  }''',
+               name : 'GCC atomic builtins')
+  pre_args += '-DUSE_GCC_ATOMIC_BUILTINS'
+
+  # Not all atomic calls can be turned into lock-free instructions, in which
+  # GCC will make calls into the libatomic library. Check whether we need to
+  # link with -latomic.
+  #
+  # This can happen for 64-bit atomic operations on 32-bit architectures such
+  # as ARM.
+  if not cc.links('''#include <stdint.h>
+                     int main() {
+                       struct {
+                         uint64_t *v;
+                       } x;
+                       return (int)__atomic_load_n(x.v, __ATOMIC_ACQUIRE) &
+                              (int)__atomic_add_fetch(x.v, (uint64_t)1, __ATOMIC_ACQ_REL);
+                     }''',
+                  name : 'GCC atomic builtins required -latomic')
+    dep_atomic = cc.find_library('atomic')
+  endif
+endif
+if not cc.links('''#include <stdint.h>
+                   uint64_t v;
+                   int main() {
+                     return __sync_add_and_fetch(&v, (uint64_t)1);
+                   }''',
+                dependencies : dep_atomic,
+                name : 'GCC 64bit atomics')
+  pre_args += '-DMISSING_64BIT_ATOMICS'
+endif
+
+dep_ws2_32 = cc.find_library('ws2_32', required : with_platform_windows)
+
+# TODO: shared/static? Is this even worth doing?
+
+with_asm_arch = ''
+if host_machine.cpu_family() == 'x86'
+  if system_has_kms_drm or host_machine.system() == 'gnu'
+    with_asm_arch = 'x86'
+    pre_args += ['-DUSE_X86_ASM']
+
+    if with_glx_read_only_text
+      pre_args += ['-DGLX_X86_READONLY_TEXT']
+    endif
+  endif
+elif host_machine.cpu_family() == 'x86_64'
+  if system_has_kms_drm
+    with_asm_arch = 'x86_64'
+    pre_args += ['-DUSE_X86_64_ASM']
+  endif
+elif host_machine.cpu_family() == 'arm'
+  if system_has_kms_drm
+    with_asm_arch = 'arm'
+    pre_args += ['-DUSE_ARM_ASM']
+  endif
+elif host_machine.cpu_family() == 'aarch64'
+  if system_has_kms_drm
+    with_asm_arch = 'aarch64'
+    pre_args += ['-DUSE_AARCH64_ASM']
+  endif
+elif host_machine.cpu_family() == 'sparc64'
+  if system_has_kms_drm
+    with_asm_arch = 'sparc'
+    pre_args += ['-DUSE_SPARC_ASM']
+  endif
+elif host_machine.cpu_family() == 'ppc64' and host_machine.endian() == 'little'
+  if system_has_kms_drm
+    with_asm_arch = 'ppc64le'
+    pre_args += ['-DUSE_PPC64LE_ASM']
+  endif
+elif host_machine.cpu_family() == 'mips64' and host_machine.endian() == 'little'
+  if system_has_kms_drm
+    with_asm_arch = 'mips64el'
+    pre_args += ['-DUSE_MIPS64EL_ASM']
+  endif
+elif host_machine.cpu_family() == 'loongarch64'
+  if system_has_kms_drm
+    with_asm_arch = 'loongarch64'
+    pre_args += ['-DUSE_LOONGARCH64_ASM']
+  endif
+endif
+
+# Check for standard headers and functions
+if (cc.has_header_symbol('sys/sysmacros.h', 'major') and
+  cc.has_header_symbol('sys/sysmacros.h', 'minor') and
+  cc.has_header_symbol('sys/sysmacros.h', 'makedev'))
+  pre_args += '-DMAJOR_IN_SYSMACROS'
+endif
+if (cc.has_header_symbol('sys/mkdev.h', 'major') and
+  cc.has_header_symbol('sys/mkdev.h', 'minor') and
+  cc.has_header_symbol('sys/mkdev.h', 'makedev'))
+  pre_args += '-DMAJOR_IN_MKDEV'
+endif
+
+if cc.check_header('sched.h')
+  pre_args += '-DHAS_SCHED_H'
+  if cc.has_function('sched_getaffinity')
+    pre_args += '-DHAS_SCHED_GETAFFINITY'
+  endif
+endif
+
+if not ['linux'].contains(host_machine.system())
+  # Deprecated on Linux and requires <sys/types.h> on FreeBSD and OpenBSD
+  if cc.check_header('sys/sysctl.h', prefix : '#include <sys/types.h>')
+    pre_args += '-DHAVE_SYS_SYSCTL_H'
+  endif
+endif
+
+foreach h : ['xlocale.h', 'linux/futex.h', 'endian.h', 'dlfcn.h', 'sys/shm.h',
+             'cet.h', 'pthread_np.h', 'renderdoc_app.h', 'sys/inotify.h', 'linux/udmabuf.h']
+  if cc.check_header(h)
+    pre_args += '-DHAVE_@0@'.format(h.to_upper().underscorify())
+  endif
+endforeach
+
+functions_to_detect = {
+  'strtof': '',
+  'mkostemp': '',
+  'memfd_create': '',
+  'random_r': '',
+  'flock': '',
+  'strtok_r': '',
+  'getrandom': '',
+  'qsort_s': '',
+  'posix_fallocate': '',
+  'secure_getenv': '',
+}
+
+foreach f, prefix: functions_to_detect
+  if cc.has_function(f, prefix: prefix)
+    pre_args += '-DHAVE_@0@'.format(f.to_upper())
+  endif
+endforeach
+
+if cpp.links('''
+    #define _GNU_SOURCE
+    #include <stdlib.h>
+
+    static int dcomp(const void *l, const void *r, void *t) { return 0; }
+
+    int main(int ac, char **av) {
+      int arr[] = { 1 };
+      void *t = NULL;
+      qsort_r((void*)&arr[0], 1, 1, dcomp, t);
+      return (0);
+    }''',
+    args : pre_args,
+    name : 'GNU qsort_r')
+  pre_args += '-DHAVE_GNU_QSORT_R'
+elif cpp.links('''
+    #include <stdlib.h>
+
+    static int dcomp(void *t, const void *l, const void *r) { return 0; }
+
+    int main(int ac, char **av) {
+      int arr[] = { 1 };
+      void *t = NULL;
+      qsort_r((void*)&arr[0], 1, 1, t, dcomp);
+      return (0);
+    }''',
+    args : pre_args,
+    name : 'BSD qsort_r')
+  pre_args += '-DHAVE_BSD_QSORT_R'
+endif
+
+if cc.has_header_symbol('time.h', 'struct timespec')
+   pre_args += '-DHAVE_STRUCT_TIMESPEC'
+endif
+
+with_c11_threads = false
+if cc.has_function('thrd_create', prefix: '#include <threads.h>')
+  if with_platform_android
+    # Current only Android's c11 <threads.h> are verified
+    pre_args += '-DHAVE_THRD_CREATE'
+    with_c11_threads = true
+  endif
+endif
+
+if cc.has_header_symbol('errno.h', 'program_invocation_name',
+                        args : '-D_GNU_SOURCE')
+   pre_args += '-DHAVE_PROGRAM_INVOCATION_NAME'
+elif with_tools.contains('intel')
+  error('Intel tools require the program_invocation_name variable')
+endif
+
+if cc.has_header_symbol('math.h', 'issignaling',
+                        args : '-D_GNU_SOURCE')
+   pre_args += '-DHAVE_ISSIGNALING'
+endif
+
+# MinGW provides a __builtin_posix_memalign function, but not a posix_memalign.
+# This means that this check will succeed, but then compilation will later
+# fail. MSVC doesn't have this function at all, so only check for it on
+# non-windows platforms.
+if host_machine.system() != 'windows'
+  if cc.has_function('posix_memalign')
+    pre_args += '-DHAVE_POSIX_MEMALIGN'
+  endif
+endif
+
+if cc.has_member('struct dirent', 'd_type', prefix: '''#include <sys/types.h>
+   #include <dirent.h>''')
+   pre_args += '-DHAVE_DIRENT_D_TYPE'
+endif
+
+# strtod locale support
+if cc.links('''
+    #define _GNU_SOURCE
+    #include <stdlib.h>
+    #include <locale.h>
+    #ifdef HAVE_XLOCALE_H
+    #include <xlocale.h>
+    #endif
+    int main() {
+      locale_t loc = newlocale(LC_CTYPE_MASK, "C", NULL);
+      const char *s = "1.0";
+      char *end;
+      double d = strtod_l(s, &end, loc);
+      float f = strtof_l(s, &end, loc);
+      freelocale(loc);
+      return 0;
+    }''',
+    args : pre_args,
+    name : 'strtod has locale support')
+  pre_args += '-DHAVE_STRTOD_L'
+endif
+
+# Check for some linker flags
+ld_args_bsymbolic = []
+if cc.links('int main() { return 0; }', args : '-Wl,-Bsymbolic', name : 'Bsymbolic')
+  ld_args_bsymbolic += '-Wl,-Bsymbolic'
+endif
+with_ld_version_script = false
+if cc.links('int main() { return 0; }',
+            args : '-Wl,--version-script=@0@'.format(
+              join_paths(meson.current_source_dir(), 'build-support/conftest.map')),
+            name : 'version-script')
+  with_ld_version_script = true
+endif
+with_ld_dynamic_list = false
+if cc.links('int main() { return 0; }',
+            args : '-Wl,--dynamic-list=@0@'.format(
+              join_paths(meson.current_source_dir(), 'build-support/conftest.dyn')),
+            name : 'dynamic-list')
+  with_ld_dynamic_list = true
+endif
+
+ld_args_build_id = cc.get_supported_link_arguments('-Wl,--build-id=sha1')
+
+# check for dl support
+dep_dl = null_dep
+if host_machine.system() != 'windows'
+  if not cc.has_function('dlopen')
+    dep_dl = cc.find_library('dl', required : true)
+  endif
+  if cc.has_function('dladdr', dependencies : dep_dl)
+    # This is really only required for util/disk_cache.h
+    pre_args += '-DHAVE_DLADDR'
+  endif
+endif
+
+if cc.has_function('dl_iterate_phdr')
+  pre_args += '-DHAVE_DL_ITERATE_PHDR'
+elif with_intel_vk or with_intel_hasvk
+  error('Intel "Anvil" Vulkan driver requires the dl_iterate_phdr function')
+endif
+
+if with_any_intel and ['x86', 'x86_64'].contains(host_machine.cpu_family())
+  pre_args += '-DSUPPORT_INTEL_INTEGRATED_GPUS'
+endif
+
+if with_gallium_i915 and host_machine.cpu_family().startswith('x86') == false
+  error('Intel "i915" Gallium driver requires x86 or x86_64 CPU family')
+endif
+
+# Determine whether or not the rt library is needed for time functions
+if host_machine.system() == 'windows' or cc.has_function('clock_gettime')
+  dep_clock = null_dep
+else
+  dep_clock = cc.find_library('rt')
+endif
+
+# IMPORTANT: We can't upgrade Zlib beyond 1.2.5 because it would break Viewperf.
+dep_zlib = dependency('zlib', version : '>= 1.2.3',
+                      allow_fallback: true,
+                      required : get_option('zlib'))
+if dep_zlib.found()
+  pre_args += '-DHAVE_ZLIB'
+endif
+
+dep_zstd = dependency('libzstd', required : get_option('zstd'))
+if dep_zstd.found()
+  pre_args += '-DHAVE_ZSTD'
+endif
+
+with_compression = dep_zlib.found() or dep_zstd.found()
+if with_compression
+  pre_args += '-DHAVE_COMPRESSION'
+elif with_shader_cache
+  error('Shader Cache requires compression')
+endif
+
+if host_machine.system() == 'windows'
+  # For MSVC and MinGW we aren't using pthreads, and dependency('threads') will add linkage
+  # to pthread for MinGW, so leave the dependency null_dep for Windows. For Windows linking to
+  # kernel32 is enough for c11/threads.h and it's already linked by meson by default
+  dep_thread = null_dep
+else
+  dep_thread = dependency('threads')
+endif
+if dep_thread.found()
+  pre_args += '-DHAVE_PTHREAD'
+  if host_machine.system() != 'netbsd' and cc.has_function(
+      'pthread_setaffinity_np',
+      dependencies : dep_thread,
+      prefix : '#include <pthread.h>',
+      args : '-D_GNU_SOURCE')
+    pre_args += '-DHAVE_PTHREAD_SETAFFINITY'
+  endif
+endif
+
+with_expat = get_option('expat') \
+  .disable_auto_if(with_platform_android or with_platform_windows)
+
+if host_machine.system() == 'darwin'
+  dep_expat = meson.get_compiler('c').find_library('expat', required : with_expat)
+else
+  dep_expat = dependency('expat', allow_fallback: true,
+                         required : with_expat)
+endif
+
+# TODO: with Meson 1.1.0 this can be replaced with with_expat.enable_if(with_intel_tools)
+if with_intel_tools and not dep_expat.found()
+  error('Intel tools require expat')
+endif
+
+# We don't require expat on Android or Windows
+use_xmlconfig = get_option('xmlconfig') \
+  .require(not (with_platform_android or with_platform_windows),
+           error_message : 'xmlconfig not available on Android or Windows') \
+  .require(dep_expat.found(),
+           error_message : 'requires expat') \
+  .allowed()
+
+# Predefined macros for windows
+if host_machine.system() == 'windows'
+  pre_args += '-DWIN32_LEAN_AND_MEAN' # http://msdn2.microsoft.com/en-us/library/6dwk3a1z.aspx
+endif
+# this only exists on linux so either this is linux and it will be found, or
+# it's not linux and wont
+dep_m = cc.find_library('m', required : false)
+
+if host_machine.system() == 'windows'
+  dep_regex = meson.get_compiler('c').find_library('regex', required : false)
+  if not dep_regex.found()
+    dep_regex = declare_dependency(compile_args : ['-DNO_REGEX'])
+  endif
+else
+  dep_regex = null_dep
+endif
+
+if with_platform_haiku
+  dep_network = cc.find_library('network')
+endif
+
+dep_futex = null_dep
+if host_machine.system() == 'windows'
+  if (get_option('min-windows-version') < 8)
+    pre_args += '-DWINDOWS_NO_FUTEX'
+  else
+    dep_futex = cc.find_library('synchronization', required : true)
+  endif
+endif
+
+# Check for libdrm. Various drivers have different libdrm version requirements,
+# but we always want to use the same version for all libdrm modules. That means
+# even if driver foo requires 2.4.0 and driver bar requires 2.4.3, if foo and
+# bar are both on use 2.4.3 for both of them
+dep_libdrm_amdgpu = null_dep
+dep_libdrm_radeon = null_dep
+dep_libdrm_intel = null_dep
+
+_drm_amdgpu_ver = '2.4.119'
+_drm_radeon_ver = '2.4.71'
+_drm_intel_ver = '2.4.75'
+_drm_ver = '2.4.109'
+
+_libdrm_checks = [
+  ['intel', with_gallium_i915],
+  ['amdgpu', (with_amd_vk and not with_platform_windows) or with_gallium_radeonsi],
+  ['radeon', (with_gallium_radeonsi or with_gallium_r300 or with_gallium_r600)],
+]
+
+# Loop over the enables versions and get the highest libdrm requirement for all
+# active drivers.
+_drm_blame = ''
+foreach d : _libdrm_checks
+  ver = get_variable('_drm_@0@_ver'.format(d[0]))
+  if d[1] and ver.version_compare('>' + _drm_ver)
+    _drm_ver = ver
+    _drm_blame = d[0]
+  endif
+endforeach
+if _drm_blame != ''
+  message('libdrm @0@ needed because @1@ has the highest requirement'.format(_drm_ver, _drm_blame))
+endif
+
+# Then get each libdrm module
+foreach d : _libdrm_checks
+  if d[1]
+    set_variable(
+      'dep_libdrm_' + d[0],
+      dependency('libdrm_' + d[0], version : '>=' + _drm_ver)
+    )
+  endif
+endforeach
+
+with_gallium_drisw_kms = false
+if system_has_kms_drm
+  dep_libdrm = dependency(
+    'libdrm', version : '>=' + _drm_ver,
+    # GNU/Hurd includes egl_dri2, without drm.
+    required : (with_dri2 and host_machine.system() != 'gnu') or with_dri3
+  )
+else
+  # We should prevent libdrm from being available when the target doesn't have it to avoid transitive
+  # dependencies (such as vk-runtime) linking to it
+  dep_libdrm = null_dep
+endif
+if dep_libdrm.found()
+  pre_args += '-DHAVE_LIBDRM'
+  if with_dri_platform == 'drm' and with_dri
+    with_gallium_drisw_kms = true
+  endif
+endif
+
+dep_libudev = dependency('libudev', required : false)
+if dep_libudev.found()
+  pre_args += '-DHAVE_LIBUDEV'
+endif
+
+llvm_modules = ['bitwriter', 'engine', 'mcdisassembler', 'mcjit', 'core', 'executionengine', 'scalaropts', 'transformutils', 'instcombine']
+llvm_optional_modules = ['coroutines']
+if with_amd_vk or with_gallium_radeonsi or with_gallium_r600
+  llvm_modules += ['amdgpu', 'bitreader', 'ipo']
+  if with_gallium_r600
+    llvm_modules += 'asmparser'
+  endif
+endif
+if with_gallium_opencl
+  llvm_modules += [
+    'linker', 'coverage', 'instrumentation', 'ipo', 'irreader',
+    'lto', 'option', 'objcarcopts', 'profiledata'
+  ]
+  # all-targets is needed to support static linking LLVM build with multiple targets
+  # windowsdriver is needded with LLVM>=15, but we don't know what LLVM verrsion we are using yet
+  llvm_optional_modules += ['all-targets', 'frontendopenmp', 'windowsdriver']
+endif
+if with_clc
+  llvm_modules += ['coverage', 'target', 'linker', 'irreader', 'option', 'libdriver', 'lto']
+  # all-targets is needed to support static linking LLVM build with multiple targets.
+  # windowsdriver is needded with LLVM>=15 and frontendhlsl is needed with LLVM>=16,
+  # but we don't know what LLVM version we are using yet
+  llvm_optional_modules += ['all-targets', 'windowsdriver', 'frontendhlsl', 'frontenddriver']
+endif
+draw_with_llvm = get_option('draw-use-llvm')
+if draw_with_llvm
+  llvm_modules += 'native'
+  # lto is needded with LLVM>=15, but we don't know what LLVM verrsion we are using yet
+  llvm_optional_modules += ['lto']
+endif
+
+if with_amd_vk or with_gallium_radeonsi or with_clc
+  _llvm_version = '>= 15.0.0'
+elif with_gallium_opencl
+  _llvm_version = '>= 11.0.0'
+else
+  _llvm_version = '>= 5.0.0'
+endif
+
+_shared_llvm = get_option('shared-llvm') \
+  .disable_auto_if(host_machine.system() == 'windows') \
+  .allowed()
+
+_llvm = get_option('llvm')
+dep_llvm = null_dep
+with_llvm = false
+if _llvm.allowed()
+  dep_llvm = dependency(
+    'llvm',
+    method : host_machine.system() == 'windows' ? 'auto' : 'config-tool',
+    version : _llvm_version,
+    modules : llvm_modules,
+    optional_modules : llvm_optional_modules,
+    required : (
+      with_amd_vk or with_gallium_radeonsi or with_gallium_opencl or with_clc
+      or _llvm.enabled()
+    ),
+    static : not _shared_llvm,
+    fallback : ['llvm', 'dep_llvm'],
+    include_type : 'system',
+  )
+  with_llvm = dep_llvm.found()
+endif
+if with_llvm
+  pre_args += '-DMESA_LLVM_VERSION_STRING="@0@"'.format(dep_llvm.version())
+  pre_args += '-DLLVM_IS_SHARED=@0@'.format(_shared_llvm.to_int())
+
+  if with_swrast_vk and not draw_with_llvm
+    error('Lavapipe requires LLVM draw support.')
+  endif
+
+  if host_machine.system() != 'windows'
+    # LLVM can be built without rtti, turning off rtti changes the ABI of C++
+    # programs, so we need to build all C++ code in mesa without rtti as well to
+    # ensure that linking works. Note that Win32 compilers does handle mismatching RTTI
+    # without issues, so only apply this for other compilers.
+    if dep_llvm.type_name() == 'internal'
+      _llvm_rtti = subproject('llvm').get_variable('has_rtti', true)
+    else
+      # The CMake finder will return 'ON', the llvm-config will return 'YES'
+      _llvm_rtti = ['ON', 'YES'].contains(dep_llvm.get_variable(cmake : 'LLVM_ENABLE_RTTI', configtool: 'has-rtti'))
+    endif
+    if _rtti != _llvm_rtti
+      if _llvm_rtti
+        error('LLVM was built with RTTI, cannot build Mesa with RTTI disabled. Remove cpp_rtti disable switch or use LLVM built without LLVM_ENABLE_RTTI.')
+      else
+        error('LLVM was built without RTTI, so Mesa must also disable RTTI. Use an LLVM built with LLVM_ENABLE_RTTI or add cpp_rtti=false.')
+      endif
+    endif
+  endif
+
+  if cc.get_argument_syntax() == 'msvc'
+    # Suppress "/DELAYLOAD:ole32.dll/shell32.dll ignored" warnings that LLVM adds
+    add_project_link_arguments(
+      '/ignore:4199',
+      language : ['c', 'cpp'],
+    )
+  endif
+elif with_amd_vk and with_aco_tests
+  error('ACO tests require LLVM, but LLVM is disabled.')
+elif with_swrast_vk
+  error('The following drivers require LLVM: Lavapipe. One of these is enabled, but LLVM is disabled.')
+elif with_gallium_opencl
+  error('The OpenCL "Clover" state tracker requires LLVM, but LLVM is disabled.')
+elif with_clc
+  error('The CLC compiler requires LLVM, but LLVM is disabled.')
+else
+  draw_with_llvm = false
+endif
+pre_args += '-DLLVM_AVAILABLE=' + (with_llvm ? '1' : '0')
+pre_args += '-DDRAW_LLVM_AVAILABLE=' + (with_llvm and draw_with_llvm ? '1' : '0')
+
+if with_clover_spirv or with_clc
+  chosen_llvm_version_array = dep_llvm.version().split('.')
+  chosen_llvm_version_major = chosen_llvm_version_array[0].to_int()
+  chosen_llvm_version_minor = chosen_llvm_version_array[1].to_int()
+
+  # Require an SPIRV-LLVM-Translator version compatible with the chosen LLVM
+  # one.
+
+  # This first version check is still needed as maybe LLVM 8.0 was picked but
+  # we do not want to accept SPIRV-LLVM-Translator 8.0.0.1 as that version
+  # does not have the required API and those are only available starting from
+  # 8.0.1.3.
+  _llvmspirvlib_min_version = '>= 8.0.1.3'
+  if with_clc
+    _llvmspirvlib_min_version = '>= 15.0.0.0'
+  endif
+
+  _llvmspirvlib_version = [
+    _llvmspirvlib_min_version,
+    '>= @0@.@1@'.format(chosen_llvm_version_major, chosen_llvm_version_minor),
+    '< @0@.@1@'.format(chosen_llvm_version_major, chosen_llvm_version_minor + 1) ]
+
+  dep_spirv_tools = dependency('SPIRV-Tools', required : true, version : '>= 2018.0')
+  # LLVMSPIRVLib is available at https://github.com/KhronosGroup/SPIRV-LLVM-Translator
+  dep_llvmspirvlib = dependency('LLVMSPIRVLib', required : true, version : _llvmspirvlib_version)
+else
+  dep_spirv_tools = null_dep
+  dep_llvmspirvlib = null_dep
+endif
+
+dep_clang = null_dep
+if with_clc
+  llvm_libdir = dep_llvm.get_variable(cmake : 'LLVM_LIBRARY_DIR', configtool: 'libdir')
+
+  dep_clang = cpp.find_library('clang-cpp', dirs : llvm_libdir, required : false)
+
+  if not dep_clang.found() or not _shared_llvm
+    clang_modules = [
+      'clangBasic', 'clangAST', 'clangCodeGen', 'clangLex',
+      'clangDriver', 'clangFrontend', 'clangFrontendTool',
+      'clangHandleCXX', 'clangHandleLLVM', 'clangSerialization',
+      'clangSema', 'clangParse', 'clangEdit', 'clangAnalysis'
+    ]
+    if dep_llvm.version().version_compare('>= 15.0')
+      clang_modules += 'clangSupport'
+    endif
+    if dep_llvm.version().version_compare('>= 16.0')
+      clang_modules += 'clangASTMatchers'
+    endif
+    if dep_llvm.version().version_compare('>= 18.0')
+      clang_modules += 'clangAPINotes'
+    endif
+
+    dep_clang = []
+    foreach m : clang_modules
+      dep_clang += cpp.find_library(m, dirs : llvm_libdir, required : true)
+    endforeach
+  endif
+endif
+
+# Be explicit about only using this lib on Windows, to avoid picking
+# up random libs with the generic name 'libversion'
+dep_version = null_dep
+if host_machine.system() == 'windows'
+  dep_version = cpp.find_library('version')
+endif
+
+dep_elf = dependency('libelf', required : false)
+if not with_platform_windows and not dep_elf.found()
+  dep_elf = cc.find_library('elf', required : false)
+endif
+if dep_elf.found()
+  pre_args += '-DUSE_LIBELF'
+elif with_gallium_radeonsi
+  error('Gallium driver radeonsi requires libelf')
+endif
+
+dep_valgrind = dependency('valgrind', required : get_option('valgrind'))
+if dep_valgrind.found()
+  pre_args += '-DHAVE_VALGRIND'
+endif
+
+# AddressSanitizer's leak reports need all the symbols to be present at exit to
+# decode well, which runs afoul of our dlopen()/dlclose()ing of the DRI drivers.
+# Set a flag so we can skip the dlclose for asan builds.
+if ['address', 'address,undefined'].contains(get_option('b_sanitize'))
+  asan_c_args = ['-DBUILT_WITH_ASAN=1']
+else
+  asan_c_args = ['-DBUILT_WITH_ASAN=0']
+endif
+
+# ThreadSanitizer can't deal with futexes, and reports races for cases we don't care about
+# so add a define to work silence these issues.
+if get_option('b_sanitize') == 'thread'
+  pre_args += '-DTHREAD_SANITIZER=1'
+  # meson versions prior to 1.4 will warn "Consider using the built-in option for sanitizers ..." 
+  # later on because it only checks whether the option starts with "-fsanitize",
+  # but there is no built-in option for adding a blacklist
+  tsan_blacklist = '-fsanitize-blacklist=@0@'.format(join_paths(meson.project_source_root(), 'build-support', 'tsan-blacklist.txt'))
+  if cc.has_argument(tsan_blacklist)
+    pre_args += tsan_blacklist
+  else
+    warning('Compiler does not support "-fsanitize-blacklist", expected race conditions will not be surpressed')
+  endif
+else
+  pre_args += '-DTHREAD_SANITIZER=0'
+endif
+
+yacc_is_bison = true
+needs_flex_bison = with_any_opengl or with_freedreno_vk or with_intel_tools or with_gallium
+
+if build_machine.system() == 'windows'
+  # Prefer the winflexbison versions, they're much easier to install and have
+  # better windows support.
+
+  prog_flex = find_program('win_flex', required : false)
+  if prog_flex.found()
+    # windows compatibility (uses <io.h> instead of <unistd.h> and _isatty,
+    # _fileno functions)
+    prog_flex = [prog_flex, '--wincompat']
+  else
+    prog_flex = [find_program('flex', 'lex', required : needs_flex_bison, disabler : true)]
+  endif
+  # Force flex to use const keyword in prototypes, as relies on __cplusplus or
+  # __STDC__ macro to determine whether it's safe to use const keyword
+  prog_flex += '-DYY_USE_CONST='
+
+  prog_flex_cpp = prog_flex
+  # Convince win_flex to use <inttypes.h> for C++ files
+  # Note that we are using a C99 version here rather than C11,
+  # because using a C11 version can cause the MSVC CRT headers to define
+  # static_assert to _Static_assert, which breaks other parts of the CRT
+  prog_flex_cpp += '-D__STDC_VERSION__=199901'
+
+  prog_bison = find_program('win_bison', required : false)
+  if not prog_bison.found()
+    prog_bison = find_program('bison', 'yacc', required : needs_flex_bison, disabler : true)
+  endif
+else
+  prog_bison = find_program('bison', required : false)
+
+  if not prog_bison.found()
+    prog_bison = find_program('byacc', required : needs_flex_bison, disabler : true)
+    yacc_is_bison = false
+  endif
+
+  # Disable deprecated keyword warnings, since we have to use them for
+  # old-bison compat.  See discussion in
+  # https://gitlab.freedesktop.org/mesa/mesa/merge_requests/2161
+  if find_program('bison', required : false, version : '> 2.3').found()
+    prog_bison = [prog_bison, '-Wno-deprecated']
+  endif
+
+  prog_flex = find_program('flex', required : needs_flex_bison, disabler : true)
+  prog_flex_cpp = prog_flex
+endif
+
+dep_selinux = null_dep
+if get_option('selinux')
+  dep_selinux = dependency('libselinux')
+  pre_args += '-DMESA_SELINUX'
+endif
+
+_libunwind = get_option('libunwind') \
+  .require(not with_platform_android, error_message : 'Android requires the use of the backtrace library, not libunwind')
+if host_machine.system() == 'darwin'
+  dep_unwind = meson.get_compiler('c').find_library('System', required : _libunwind)
+else
+  dep_unwind = dependency('libunwind', required : _libunwind)
+endif
+if dep_unwind.found()
+  pre_args += '-DHAVE_LIBUNWIND'
+endif
+
+if with_osmesa
+  if not with_gallium_softpipe
+    error('OSMesa gallium requires gallium softpipe or llvmpipe.')
+  endif
+  if host_machine.system() == 'windows'
+    osmesa_lib_name = 'osmesa'
+  else
+    osmesa_lib_name = 'OSMesa'
+  endif
+endif
+
+# TODO: symbol mangling
+
+if with_platform_wayland
+  dep_wl_scanner = dependency('wayland-scanner', native: true)
+  prog_wl_scanner = find_program(dep_wl_scanner.get_variable(pkgconfig : 'wayland_scanner'))
+  if dep_wl_scanner.version().version_compare('>= 1.15')
+    wl_scanner_arg = 'private-code'
+  else
+    wl_scanner_arg = 'code'
+  endif
+  dep_wl_protocols = dependency('wayland-protocols', version : '>= 1.34')
+  dep_wayland_client = dependency('wayland-client', version : '>=1.18')
+  dep_wayland_server = dependency('wayland-server', version : '>=1.18')
+  if with_egl
+    dep_wayland_egl = dependency('wayland-egl-backend', version : '>= 3')
+    dep_wayland_egl_headers = dep_wayland_egl.partial_dependency(compile_args : true)
+  endif
+  pre_args += '-DWL_HIDE_DEPRECATED'
+  if cc.has_function(
+      'wl_display_dispatch_queue_timeout',
+      prefix : '#include <wayland-client.h>',
+      dependencies: dep_wayland_client)
+    pre_args += ['-DHAVE_WL_DISPATCH_QUEUE_TIMEOUT']
+  endif
+  if cc.has_function(
+      'wl_display_create_queue_with_name',
+      prefix : '#include <wayland-client.h>',
+      dependencies: dep_wayland_client)
+    pre_args += ['-DHAVE_WL_CREATE_QUEUE_WITH_NAME']
+  endif
+endif
+
+dep_x11 = null_dep
+dep_xext = null_dep
+dep_xfixes = null_dep
+dep_x11_xcb = null_dep
+dep_xcb = null_dep
+dep_xcb_keysyms = null_dep
+dep_xcb_glx = null_dep
+dep_xcb_dri2 = null_dep
+dep_xcb_dri3 = null_dep
+dep_dri2proto = null_dep
+dep_glproto = null_dep
+dep_xxf86vm = null_dep
+dep_xcb_dri3 = null_dep
+dep_xcb_present = null_dep
+dep_xcb_sync = null_dep
+dep_xcb_xfixes = null_dep
+dep_xshmfence = null_dep
+dep_xcb_xrandr = null_dep
+dep_xcb_shm = null_dep
+dep_xlib_xrandr = null_dep
+dep_openmp = null_dep
+
+# Even if we find OpenMP, Gitlab CI fails to link with gcc/i386 and clang/anyarch.
+if host_machine.cpu_family() == 'x86_64' and cc.get_id() == 'gcc'
+  dep_openmp = dependency('openmp', required : false)
+  if dep_openmp.found()
+    pre_args += ['-DHAVE_OPENMP']
+  endif
+endif
+
+with_dri3_modifiers = false
+with_dri3_explicit_sync = false
+with_xcb_keysyms = false
+if with_platform_x11
+  if with_glx == 'xlib'
+    dep_x11 = dependency('x11')
+    dep_xext = dependency('xext')
+    dep_xcb = dependency('xcb')
+    dep_xcb_xrandr = dependency('xcb-randr')
+  elif with_glx == 'dri'
+    dep_x11 = dependency('x11')
+    dep_xext = dependency('xext')
+    dep_xfixes = dependency('xfixes', version : '>= 2.0')
+    dep_xcb_glx = dependency('xcb-glx', version : '>= 1.8.1')
+    dep_xcb_shm = dependency('xcb-shm')
+  elif with_gallium_rusticl
+    # needed for GL sharing extension
+    dep_x11 = dependency('x11')
+  endif
+  if (with_any_vk or with_glx == 'dri' or with_egl or
+       (with_gallium_vdpau or with_gallium_va or
+        with_gallium_omx != 'disabled'))
+    dep_xcb = dependency('xcb')
+    dep_xcb_keysyms = dependency('xcb-keysyms', required : false)
+    with_xcb_keysyms = dep_xcb_keysyms.found()
+    if with_xcb_keysyms
+      pre_args += '-DXCB_KEYSYMS_AVAILABLE'
+    endif
+    dep_x11_xcb = dependency('x11-xcb')
+    dep_xcb_dri2 = dependency('xcb-dri2', version : '>= 1.8')
+    if with_dri_platform == 'drm' and not dep_libdrm.found()
+      error('libdrm required for gallium video statetrackers when using x11')
+    endif
+  endif
+  if with_any_vk or with_egl or (with_glx == 'dri' and with_dri_platform == 'drm')
+    dep_xcb_dri2 = dependency('xcb-dri2', version : '>= 1.8')
+
+    if with_dri3
+      dep_xcb_dri3 = dependency('xcb-dri3')
+      dep_xcb_present = dependency('xcb-present')
+      # until xcb-dri3 has been around long enough to make a hard-dependency:
+      if (dep_xcb_dri3.version().version_compare('>= 1.13') and
+          dep_xcb_present.version().version_compare('>= 1.13'))
+        with_dri3_modifiers = true
+      endif
+      if (dep_xcb_dri3.version().version_compare('>= 1.17') and
+          dep_xcb_present.version().version_compare('>= 1.17'))
+        with_dri3_explicit_sync = true
+      endif
+      dep_xcb_shm = dependency('xcb-shm')
+      dep_xcb_sync = dependency('xcb-sync')
+      dep_xshmfence = dependency('xshmfence', version : '>= 1.1')
+    endif
+  endif
+  if with_glx == 'dri' or with_glx == 'xlib'
+    dep_glproto = dependency('glproto', version : '>= 1.4.14')
+  endif
+  if with_glx == 'dri'
+    if with_dri_platform == 'drm'
+      dep_dri2proto = dependency('dri2proto', version : '>= 2.8')
+      if with_glx_direct
+        dep_xxf86vm = dependency('xxf86vm')
+      endif
+    endif
+  endif
+  if (with_egl or
+      with_dri3 or (
+      with_gallium_vdpau or with_gallium_xa or
+      with_gallium_omx != 'disabled'))
+    dep_xcb_xfixes = dependency('xcb-xfixes')
+  endif
+  if with_xlib_lease or with_any_vk
+    dep_xcb_xrandr = dependency('xcb-randr')
+  endif
+  if with_xlib_lease
+    dep_xlib_xrandr = dependency('xrandr', version : '>= 1.3')
+  endif
+endif
+
+if with_dri
+  pre_args += '-DHAVE_DRI'
+endif
+if with_dri2
+  pre_args += '-DHAVE_DRI2'
+endif
+if with_dri3
+  pre_args += '-DHAVE_DRI3'
+endif
+if with_dri3_modifiers
+  pre_args += '-DHAVE_DRI3_MODIFIERS'
+endif
+if with_dri3_explicit_sync
+  pre_args += '-DHAVE_DRI3_EXPLICIT_SYNC'
+endif
+if with_gallium_drisw_kms
+  pre_args += '-DHAVE_DRISW_KMS'
+endif
+
+if get_option('gallium-extra-hud')
+  pre_args += '-DHAVE_GALLIUM_EXTRA_HUD=1'
+endif
+
+dep_lmsensors = cc.find_library('sensors', required : get_option('lmsensors'))
+if dep_lmsensors.found()
+  pre_args += '-DHAVE_LIBSENSORS=1'
+endif
+
+_shader_replacement = get_option('custom-shader-replacement')
+if _shader_replacement == ''
+else
+  pre_args += '-DCUSTOM_SHADER_REPLACEMENT'
+endif
+
+with_perfetto = get_option('perfetto')
+with_datasources = get_option('datasources')
+with_any_datasource = with_datasources.length() != 0
+if with_perfetto
+  dep_perfetto = dependency('perfetto', fallback: ['perfetto', 'dep_perfetto'])
+  pre_args += '-DHAVE_PERFETTO'
+endif
+
+with_teflon = get_option('teflon')
+if with_teflon and with_tests
+  dep_xtensor = dependency('xtensor')
+  dep_flatbuffers = dependency('flatbuffers')
+  prog_flatc = find_program('flatc')
+endif
+
+with_gpuvis = get_option('gpuvis')
+if with_gpuvis
+  pre_args += '-DHAVE_GPUVIS'
+endif
+
+add_project_arguments(pre_args, language : ['c', 'cpp'])
+add_project_arguments(c_cpp_args, language : ['c', 'cpp'])
+
+add_project_arguments(c_args,   language : ['c'])
+add_project_arguments(cpp_args, language : ['cpp'])
+
+gl_priv_reqs = []
+
+if with_glx == 'xlib'
+  gl_priv_reqs += ['x11', 'xext', 'xcb']
+elif with_glx == 'dri'
+  gl_priv_reqs += [
+    'x11', 'xext', 'xfixes', 'x11-xcb', 'xcb',
+    'xcb-glx >= 1.8.1']
+  if with_dri_platform == 'drm'
+    gl_priv_reqs += 'xcb-dri2 >= 1.8'
+    if with_glx_direct
+      gl_priv_reqs += 'xxf86vm'
+    endif
+  endif
+endif
+if dep_libdrm.found()
+  gl_priv_reqs += 'libdrm >= 2.4.75'
+endif
+
+gl_priv_libs = []
+if dep_thread.found()
+  gl_priv_libs += ['-lpthread', '-pthread']
+endif
+if dep_m.found()
+  gl_priv_libs += '-lm'
+endif
+if dep_dl.found()
+  gl_priv_libs += '-ldl'
+endif
+
+# FIXME: autotools lists this as incomplete
+gbm_priv_libs = []
+if dep_dl.found()
+  gbm_priv_libs += '-ldl'
+endif
+
+pkg = import('pkgconfig')
+
+if host_machine.system() == 'windows'
+  prog_dumpbin = find_program('dumpbin', required : false)
+  with_symbols_check = prog_dumpbin.found() and with_tests
+  if with_symbols_check
+    symbols_check_args = ['--dumpbin', prog_dumpbin.full_path()]
+  endif
+else
+  prog_nm = find_program('nm')
+  with_symbols_check = with_tests
+  symbols_check_args = ['--nm', prog_nm.full_path()]
+endif
+
+# This quirk needs to be applied to sources with functions defined in assembly
+# as GCC LTO drops them. See: https://bugs.freedesktop.org/show_bug.cgi?id=109391
+gcc_lto_quirk = (cc.get_id() == 'gcc') ? ['-fno-lto'] : []
+
+devenv = environment()
+
+dir_compiler_nir = join_paths(meson.current_source_dir(), 'src/compiler/nir/')
+dir_source_root = meson.project_source_root()
+
+
+subdir('include')
+subdir('bin')
+subdir('src')
+
+meson.add_devenv(devenv)
+
+summary(
+  {
+    'prefix': get_option('prefix'),
+    'libdir': get_option('libdir'),
+    'includedir': get_option('includedir'),
+  },
+  section: 'Directories'
+)
+
+summary(
+  {
+    'c_cpp_args': c_cpp_args,
+  },
+  section: 'Common C and C++ arguments'
+)
+
+summary(
+  {
+    'OpenGL': with_opengl,
+    'ES1': with_gles1,
+    'ES2': with_gles2,
+    'Shared glapi': with_shared_glapi,
+    'GLVND': with_glvnd,
+  },
+  section: 'OpenGL', bool_yn: true
+)
+
+summary(
+  {
+    'Platform': with_dri_platform,
+    'Driver dir': dri_drivers_path,
+  },
+  section: 'DRI', bool_yn: true, list_sep: ' '
+)
+
+summary(
+  {
+    'Enabled': with_glx != 'disabled',
+    'Provider': with_glx == 'disabled' ? 'None' : with_glx
+  },
+  section: 'GLX', bool_yn: true, list_sep: ' '
+)
+
+egl_summary = {'Enabled': with_egl}
+if with_egl
+  egl_drivers = []
+  if with_dri
+    egl_drivers += 'builtin:egl_dri2'
+  endif
+  if with_dri3
+    egl_drivers += 'builtin:egl_dri3'
+  endif
+  if with_platform_windows
+    egl_drivers += 'builtin:wgl'
+  endif
+  egl_summary += {'Drivers': egl_drivers}
+  egl_summary += {'Platforms': _platforms}
+endif
+summary(egl_summary, section: 'EGL', bool_yn: true, list_sep: ' ')
+
+gbm_summary = {'Enabled': with_gbm}
+if with_gbm
+  gbm_summary += {'Backends path': gbm_backends_path}
+endif
+summary(gbm_summary, section: 'GBM', bool_yn: true, list_sep: ' ')
+
+vulkan_summary = {'Drivers': _vulkan_drivers.length() != 0 ? _vulkan_drivers : false }
+if with_any_vk
+  vulkan_summary += {'Platforms': _platforms}
+  vulkan_summary += {'ICD dir': with_vulkan_icd_dir}
+  if with_any_vulkan_layers
+    vulkan_summary += {'Layers': get_option('vulkan-layers')}
+  endif
+  vulkan_summary += {'Intel Ray tracing': with_intel_vk_rt}
+endif
+summary(vulkan_summary, section: 'Vulkan', bool_yn: true, list_sep: ' ')
+
+video_summary = {'Codecs': _codecs.length() != 0 ? _codecs : false}
+video_apis = []
+if with_gallium_vdpau
+  video_apis += 'vdpau'
+endif
+if with_gallium_va
+  video_apis += 'va'
+endif
+if with_any_vk
+  video_apis += 'vulkan'
+endif
+if with_gallium_xa
+  video_apis += 'xa'
+endif
+if with_gallium_omx != 'disabled'
+  video_apis += 'omx'
+endif
+video_summary += {'APIs': video_apis.length() != 0 ? video_apis : false}
+summary(video_summary, section: 'Video', bool_yn: true, list_sep: ' ')
+
+llvm_summary = {'Enabled': with_llvm}
+if with_llvm
+  llvm_summary += {'Version': dep_llvm.version()}
+endif
+summary(llvm_summary, section: 'LLVM', bool_yn: true, list_sep: ' ')
+
+gallium_summary = {'Enabled': with_gallium}
+if with_gallium
+  gallium_summary += {'Drivers': gallium_drivers}
+  gallium_summary += {'Platforms': _platforms}
+
+  gallium_frontends = ['mesa']
+  if with_gallium_xa
+    gallium_frontends += 'xa'
+  endif
+  if with_gallium_vdpau
+    gallium_frontends += 'vdpau'
+  endif
+  if with_gallium_omx != 'disabled'
+    gallium_frontends += 'omx' + with_gallium_omx
+  endif
+  if with_gallium_va
+    gallium_frontends += 'va'
+  endif
+  if with_gallium_st_nine
+    gallium_frontends += 'nine'
+  endif
+  if with_gallium_opencl
+    gallium_frontends += 'clover'
+  endif
+  if with_gallium_rusticl
+    gallium_frontends += 'rusticl'
+  endif
+  gallium_summary += {'Frontends': gallium_frontends}
+  gallium_summary += {'Off-screen rendering (OSMesa)': with_osmesa ? 'lib' + osmesa_lib_name : false}
+  gallium_summary += {'HUD lm-sensors': dep_lmsensors.found()}
+endif
+summary(gallium_summary, section: 'Gallium', bool_yn: true, list_sep: ' ')
+
+perfetto_summary = {'Enabled': with_perfetto}
+if with_perfetto and with_any_datasource
+  perfetto_summary += {'Data source': with_datasources}
+endif
+summary(perfetto_summary, section: 'Perfetto', bool_yn: true, list_sep: ' ')
+
+teflon_summary = {'Enabled': with_teflon}
+summary(teflon_summary, section: 'Teflon (TensorFlow Lite delegate)', bool_yn: true, list_sep: ' ')
diff --git a/meson_options.txt b/meson_options.txt
index 7c021c14cfe..9ad39cc5b97 100644
--- a/meson_options.txt
+++ b/meson_options.txt
@@ -423,6 +423,13 @@ option(
                 'is included.'
 )
 
+option (
+  'llvm-orcjit',
+  type : 'boolean',
+  value : false,
+  description: 'Build llvmpipe with LLVM ORCJIT support.'
+)
+
 option(
   'valgrind',
   type : 'feature',
diff --git a/src/gallium/auxiliary/gallivm/lp_bld.h b/src/gallium/auxiliary/gallivm/lp_bld.h
index 24e64fec2bf..dbd3561065b 100644
--- a/src/gallium/auxiliary/gallivm/lp_bld.h
+++ b/src/gallium/auxiliary/gallivm/lp_bld.h
@@ -50,6 +50,10 @@
 
 #include <llvm-c/Core.h>
 
+#if GALLIVM_USE_ORCJIT
+#include <llvm-c/Orc.h>
+#endif
+
 #include <assert.h>
 #include <stdbool.h>
 #include <stddef.h>
@@ -132,7 +136,11 @@ LLVMBuildCall2(LLVMBuilderRef B, LLVMTypeRef Ty, LLVMValueRef Fn,
 #endif /* LLVM_VERSION_MAJOR < 8 */
 
 typedef struct lp_context_ref {
+#if GALLIVM_USE_ORCJIT
+   LLVMOrcThreadSafeContextRef ref;
+#else
    LLVMContextRef ref;
+#endif
    bool owned;
 } lp_context_ref;
 
@@ -140,11 +148,19 @@ static inline void
 lp_context_create(lp_context_ref *context)
 {
    assert(context != NULL);
+#if GALLIVM_USE_ORCJIT
+   context->ref = LLVMOrcCreateNewThreadSafeContext();
+#else
    context->ref = LLVMContextCreate();
+#endif
    context->owned = true;
 #if LLVM_VERSION_MAJOR == 15
    if (context->ref) {
+#if GALLIVM_USE_ORCJIT
+      LLVMContextSetOpaquePointers(LLVMOrcThreadSafeContextGetContext(context->ref), false);
+#else
       LLVMContextSetOpaquePointers(context->ref, false);
+#endif
    }
 #endif
 }
@@ -154,7 +170,11 @@ lp_context_destroy(lp_context_ref *context)
 {
    assert(context != NULL);
    if (context->owned) {
+#if GALLIVM_USE_ORCJIT
+      LLVMOrcDisposeThreadSafeContext(context->ref);
+#else
       LLVMContextDispose(context->ref);
+#endif
       context->ref = NULL;
    }
 }
diff --git a/src/gallium/auxiliary/gallivm/lp_bld_coro.c b/src/gallium/auxiliary/gallivm/lp_bld_coro.c
index c2d6cc11cc6..4d5081e4142 100644
--- a/src/gallium/auxiliary/gallivm/lp_bld_coro.c
+++ b/src/gallium/auxiliary/gallivm/lp_bld_coro.c
@@ -161,7 +161,9 @@ coro_free(char *ptr)
 
 void lp_build_coro_add_malloc_hooks(struct gallivm_state *gallivm)
 {
+#if !GALLIVM_USE_ORCJIT
    assert(gallivm->engine);
+#endif
 
    assert(gallivm->coro_malloc_hook);
    assert(gallivm->coro_free_hook);
diff --git a/src/gallium/auxiliary/gallivm/lp_bld_init.h b/src/gallium/auxiliary/gallivm/lp_bld_init.h
index 651d667d2bb..15549d10962 100644
--- a/src/gallium/auxiliary/gallivm/lp_bld_init.h
+++ b/src/gallium/auxiliary/gallivm/lp_bld_init.h
@@ -35,7 +35,12 @@
 #include "util/u_cpu_detect.h"
 #include "lp_bld.h"
 #include "lp_bld_passmgr.h"
+
+#if GALLIVM_USE_ORCJIT
+#include <llvm-c/Orc.h>
+#else
 #include <llvm-c/ExecutionEngine.h>
+#endif
 
 #ifdef __cplusplus
 extern "C" {
@@ -46,13 +51,20 @@ struct gallivm_state
 {
    char *module_name;
    LLVMModuleRef module;
-   LLVMExecutionEngineRef engine;
    LLVMTargetDataRef target;
+#if GALLIVM_USE_ORCJIT
+   /* own this->module */
+   LLVMOrcThreadSafeContextRef _ts_context;
+   /* each module is in its own jitdylib */
+   LLVMOrcJITDylibRef _per_module_jd;
+#else
+   LLVMExecutionEngineRef engine;
    struct lp_passmgr *passmgr;
-   LLVMContextRef context;
-   LLVMBuilderRef builder;
    LLVMMCJITMemoryManagerRef memorymgr;
    struct lp_generated_code *code;
+#endif
+   LLVMContextRef context;
+   LLVMBuilderRef builder;
    struct lp_cached_code *cache;
    unsigned compiled;
    LLVMValueRef coro_malloc_hook;
diff --git a/src/gallium/auxiliary/gallivm/lp_bld_init_orc.cpp b/src/gallium/auxiliary/gallivm/lp_bld_init_orc.cpp
new file mode 100644
index 00000000000..12c7aadb2b2
--- /dev/null
+++ b/src/gallium/auxiliary/gallivm/lp_bld_init_orc.cpp
@@ -0,0 +1,586 @@
+#include "util/detect.h"
+#include "util/u_cpu_detect.h"
+#include "util/u_debug.h"
+#include "util/os_time.h"
+#include <string>
+#include <vector>
+#include "lp_bld.h"
+#include "lp_bld_debug.h"
+#include "lp_bld_init.h"
+#include "lp_bld_coro.h"
+#include "lp_bld_misc.h"
+#include "lp_bld_printf.h"
+#include "lp_bld_passmgr.h"
+#include "lp_bld_type.h"
+
+#include <llvm/Config/llvm-config.h>
+#include <llvm-c/Core.h>
+#include <llvm-c/Orc.h>
+#include <llvm-c/LLJIT.h>
+#include <llvm-c/TargetMachine.h>
+#include <llvm-c/Support.h>
+
+#include <llvm-c/Analysis.h>
+#if LLVM_VERSION_MAJOR < 17
+#include <llvm-c/Transforms/Scalar.h>
+#if LLVM_VERSION_MAJOR >= 7
+#include <llvm-c/Transforms/Utils.h>
+#endif
+#endif
+#include <llvm-c/BitWriter.h>
+
+#include <llvm/ADT/StringMap.h>
+#include <llvm/ExecutionEngine/Orc/LLJIT.h>
+#include <llvm/ExecutionEngine/Orc/ObjectLinkingLayer.h>
+#include "llvm/ExecutionEngine/JITLink/JITLink.h"
+#include <llvm/Target/TargetMachine.h>
+#include <llvm/Support/TargetSelect.h>
+#include <llvm/Support/Casting.h>
+#if LLVM_VERSION_MAJOR >= 18
+#include <llvm/TargetParser/Host.h>
+#else
+#include <llvm/Support/Host.h>
+#endif
+#include <llvm/Support/CBindingWrapping.h>
+#if LLVM_USE_INTEL_JITEVENTS
+#include <llvm/ExecutionEngine/JITEventListener.h>
+#endif
+
+/* conflict with ObjectLinkingLayer.h */
+#include "util/u_memory.h"
+
+#if DETECT_ARCH_RISCV64 == 1 || DETECT_ARCH_RISCV32 == 1 || (defined(_WIN32) && LLVM_VERSION_MAJOR >= 15)
+/* use ObjectLinkingLayer (JITLINK backend) */
+#define USE_JITLINK
+#endif
+/* else use old RTDyldObjectLinkingLayer (RuntimeDyld backend) */
+
+namespace {
+
+class LPJit;
+
+class LLVMEnsureMultithreaded {
+public:
+   LLVMEnsureMultithreaded()
+   {
+      if (!LLVMIsMultithreaded()) {
+         LLVMStartMultithreaded();
+      }
+   }
+};
+
+LLVMEnsureMultithreaded lLVMEnsureMultithreaded;
+
+DEFINE_SIMPLE_CONVERSION_FUNCTIONS(llvm::orc::ThreadSafeContext,
+                                   LLVMOrcThreadSafeContextRef)
+DEFINE_SIMPLE_CONVERSION_FUNCTIONS(llvm::orc::IRTransformLayer,
+                                   LLVMOrcIRTransformLayerRef)
+DEFINE_SIMPLE_CONVERSION_FUNCTIONS(llvm::orc::JITDylib, LLVMOrcJITDylibRef)
+DEFINE_SIMPLE_CONVERSION_FUNCTIONS(llvm::orc::JITTargetMachineBuilder,
+                                   LLVMOrcJITTargetMachineBuilderRef)
+LLVMTargetMachineRef wrap(const llvm::TargetMachine *P) {
+   return reinterpret_cast<LLVMTargetMachineRef>(const_cast<llvm::TargetMachine*>(P));
+}
+
+llvm::ExitOnError ExitOnErr;
+
+inline const char* get_module_name(LLVMModuleRef mod) {
+   using llvm::Module;
+   return llvm::unwrap(mod)->getModuleIdentifier().c_str();
+}
+
+once_flag init_lpjit_once_flag = ONCE_FLAG_INIT;
+
+/* A JIT singleton built upon LLJIT */
+class LPJit
+{
+public:
+   static LPJit* get_instance() {
+      call_once(&init_lpjit_once_flag, init_lpjit);
+      return jit;
+   }
+
+   gallivm_state *find_gallivm_state(LLVMModuleRef mod) {
+#if DEBUG
+      using llvm::Module;
+      auto I = gallivm_modules.find(llvm::unwrap(mod)->getModuleIdentifier());
+      if (I == gallivm_modules.end()) {
+         debug_printf("No gallivm state found for module: %s", get_module_name(mod));
+         return NULL;
+      }
+      return I->second;
+#endif
+      return NULL;
+   }
+
+   static char *get_unique_name(const char* name) {
+      LPJit* jit = get_instance();
+      size_t size = name == NULL? 16: strlen(name) + 16;
+      char *name_uniq = (char *)MALLOC(size);
+      if (!name_uniq) {
+         return NULL;
+      }
+      do {
+         snprintf(name_uniq, size, "%s_%u", name, jit->jit_dylib_count++);
+      } while(jit->lljit->getExecutionSession().getJITDylibByName(name_uniq));
+      return name_uniq;
+   }
+
+   static LLVMOrcJITDylibRef create_jit_dylib(const char * name) {
+      using llvm::orc::JITDylib;
+      LPJit* jit = get_instance();
+      JITDylib& tmp = ExitOnErr(jit->lljit->createJITDylib(name));
+      return wrap(&tmp);
+   }
+
+   static void register_gallivm_state(gallivm_state *gallivm) {
+#if DEBUG
+      LPJit* jit = get_instance();
+      jit->gallivm_modules[gallivm->module_name] = gallivm;
+#endif
+   }
+
+   static void deregister_gallivm_state(gallivm_state *gallivm) {
+#if DEBUG
+      LPJit* jit = get_instance();
+      (void)jit->gallivm_modules.erase(gallivm->module_name);
+#endif
+   }
+
+   static void add_ir_module_to_jd(
+         LLVMOrcThreadSafeContextRef ts_context,
+         LLVMModuleRef mod,
+         LLVMOrcJITDylibRef jd) {
+      using llvm::Module;
+      using llvm::orc::ThreadSafeModule;
+      using llvm::orc::JITDylib;
+      ThreadSafeModule tsm(
+         std::unique_ptr<Module>(llvm::unwrap(mod)), *::unwrap(ts_context));
+      ExitOnErr(get_instance()->lljit->addIRModule(
+         *::unwrap(jd), std::move(tsm)
+      ));
+   }
+
+   static void add_mapping_to_jd(
+         LLVMValueRef sym,
+         void *addr,
+         LLVMOrcJITDylibRef jd) {
+#if LLVM_VERSION_MAJOR >= 17
+      using llvm::orc::ExecutorAddr;
+      using llvm::orc::ExecutorSymbolDef;
+      using llvm::JITSymbolFlags;
+#else
+      using llvm::JITEvaluatedSymbol;
+#endif
+      using llvm::orc::ExecutionSession;
+      using llvm::orc::JITDylib;
+      using llvm::orc::SymbolMap;
+      JITDylib* JD = ::unwrap(jd);
+      auto& es = LPJit::get_instance()->lljit->getExecutionSession();
+      auto name = es.intern(llvm::unwrap(sym)->getName());
+      SymbolMap map(1);
+#if LLVM_VERSION_MAJOR >= 17
+      map[name] = ExecutorSymbolDef(ExecutorAddr::fromPtr(addr), JITSymbolFlags::Exported);
+#else
+      map[name] = JITEvaluatedSymbol::fromPointer(addr);
+#endif
+      auto munit = llvm::orc::absoluteSymbols(map);
+      llvm::cantFail(JD->define(std::move(munit)));
+   }
+
+   static void *lookup_in_jd(
+         const char *func_name,
+         LLVMOrcJITDylibRef jd) {
+      using llvm::orc::JITDylib;
+      using llvm::JITEvaluatedSymbol;
+      using llvm::orc::ExecutorAddr;
+      JITDylib* JD = ::unwrap(jd);
+      auto func = ExitOnErr(LPJit::get_instance()->lljit->lookup(*JD, func_name));
+#if LLVM_VERSION_MAJOR >= 16
+      return func.toPtr<void *>();
+#else
+      return (void *)(func.getAddress());
+#endif
+   }
+
+   static void remove_jd(LLVMOrcJITDylibRef jd) {
+      using llvm::orc::ExecutionSession;
+      using llvm::orc::JITDylib;
+      auto& es = LPJit::get_instance()->lljit->getExecutionSession();
+      ExitOnErr(es.removeJITDylib(* ::unwrap(jd)));
+   }
+
+   LLVMTargetMachineRef tm;
+
+private:
+   LPJit();
+   ~LPJit() = default;
+   LPJit(const LPJit&) = delete;
+   LPJit& operator=(const LPJit&) = delete;
+
+   static void init_native_targets();
+   llvm::orc::JITTargetMachineBuilder create_jtdb();
+
+   static void init_lpjit() {
+      jit = new LPJit;
+   }
+   static LPJit* jit;
+
+   std::unique_ptr<llvm::orc::LLJIT> lljit;
+   /* avoid name conflict */
+   unsigned jit_dylib_count;
+
+#if DEBUG
+   /* map from module name to gallivm_state */
+   llvm::StringMap<gallivm_state *> gallivm_modules;
+#endif
+};
+
+LPJit* LPJit::jit = NULL;
+
+LLVMErrorRef module_transform(void *Ctx, LLVMModuleRef mod) {
+   struct lp_passmgr *mgr;
+
+   lp_passmgr_create(mod, &mgr);
+
+   lp_passmgr_run(mgr, mod,
+                  LPJit::get_instance()->tm,
+                  get_module_name(mod));
+
+   lp_passmgr_dispose(mgr);
+   return LLVMErrorSuccess;
+}
+
+LLVMErrorRef module_transform_wrapper(
+      void *Ctx, LLVMOrcThreadSafeModuleRef *ModInOut,
+      LLVMOrcMaterializationResponsibilityRef MR) {
+   return LLVMOrcThreadSafeModuleWithModuleDo(*ModInOut, *module_transform, Ctx);
+}
+
+LPJit::LPJit() :jit_dylib_count(0) {
+   using namespace llvm::orc;
+
+   lp_init_env_options();
+
+   init_native_targets();
+   JITTargetMachineBuilder JTMB = create_jtdb();
+   tm = wrap(ExitOnErr(JTMB.createTargetMachine()).release());
+
+   /* Create an LLJIT instance with an ObjectLinkingLayer (JITLINK)
+    * or RuntimeDyld as the base layer.
+    * intel & perf listeners are not supported by ObjectLinkingLayer yet
+    */
+   lljit = ExitOnErr(
+      LLJITBuilder()
+         .setJITTargetMachineBuilder(std::move(JTMB))
+#ifdef USE_JITLINK
+         .setObjectLinkingLayerCreator(
+            [&](ExecutionSession &ES, const llvm::Triple &TT) {
+               return std::make_unique<ObjectLinkingLayer>(
+                  ES, ExitOnErr(llvm::jitlink::InProcessMemoryManager::Create()));
+            })
+#else
+#if LLVM_USE_INTEL_JITEVENTS
+         .RegisterJITEventListener(
+               llvm::JITEventListener::createIntelJITEventListener())
+#endif
+#endif
+         .create());
+
+   LLVMOrcIRTransformLayerRef TL = wrap(&lljit->getIRTransformLayer());
+   LLVMOrcIRTransformLayerSetTransform(TL, *module_transform_wrapper, NULL);
+}
+
+void LPJit::init_native_targets() {
+
+   lp_bld_init_native_targets();
+
+   lp_build_init_native_width();
+
+   lp_bld_ppc_disable_denorms();
+}
+
+llvm::orc::JITTargetMachineBuilder LPJit::create_jtdb() {
+   using namespace llvm;
+   using orc::JITTargetMachineBuilder;
+
+#if defined(_WIN32) && LLVM_VERSION_MAJOR < 15
+   /*
+    * JITLink works on Windows, but only through ELF object format.
+    *
+    * XXX: We could use `LLVM_HOST_TRIPLE "-elf"` but LLVM_HOST_TRIPLE has
+    * different strings for MinGW/MSVC, so better play it safe and be
+    * explicit.
+    */
+#  ifdef _WIN64
+   JITTargetMachineBuilder JTMB((Triple("x86_64-pc-win32-elf")));
+#  else
+   JITTargetMachineBuilder JTMB((Triple("i686-pc-win32-elf")));
+#  endif
+#else
+   /*
+    * llvm::sys::getProcessTriple() is bogus. It returns the host LLVM was
+    * compiled on. Be careful when doing cross compilation
+    */
+   JITTargetMachineBuilder JTMB((Triple(sys::getProcessTriple())));
+#endif
+
+   TargetOptions options;
+   /**
+    * LLVM 3.1+ haven't more "extern unsigned llvm::StackAlignmentOverride" and
+    * friends for configuring code generation options, like stack alignment.
+    */
+#if DETECT_ARCH_X86 == 1 && LLVM_VERSION_MAJOR < 13
+   options.StackAlignmentOverride = 4;
+#endif
+
+#if DETECT_ARCH_RISCV64 == 1
+#if defined(__riscv_float_abi_soft)
+   options.MCOptions.ABIName = "lp64";
+#elif defined(__riscv_float_abi_single)
+   options.MCOptions.ABIName = "lp64f";
+#elif defined(__riscv_float_abi_double)
+   options.MCOptions.ABIName = "lp64d";
+#else
+#error "GALLIVM: unknown target riscv float abi"
+#endif
+#endif
+
+#if DETECT_ARCH_RISCV32 == 1
+#if defined(__riscv_float_abi_soft)
+   options.MCOptions.ABIName = "ilp32";
+#elif defined(__riscv_float_abi_single)
+   options.MCOptions.ABIName = "ilp32f";
+#elif defined(__riscv_float_abi_double)
+   options.MCOptions.ABIName = "ilp32d";
+#else
+#error "GALLIVM: unknown target riscv float abi"
+#endif
+#endif
+
+   JTMB.setOptions(options);
+
+   std::vector<std::string> MAttrs;
+
+   lp_build_fill_mattrs(MAttrs);
+
+   JTMB.addFeatures(MAttrs);
+
+   lp_build_dump_mattrs(MAttrs);
+
+   std::string MCPU = llvm::sys::getHostCPUName().str();
+   /*
+    * Note that the MAttrs set above will be sort of ignored (since we should
+    * not set any which would not be set by specifying the cpu anyway).
+    * It ought to be safe though since getHostCPUName() should include bits
+    * not only from the cpu but environment as well (for instance if it's safe
+    * to use avx instructions which need OS support). According to
+    * http://llvm.org/bugs/show_bug.cgi?id=19429 however if I understand this
+    * right it may be necessary to specify older cpu (or disable mattrs) though
+    * when not using MCJIT so no instructions are generated which the old JIT
+    * can't handle. Not entirely sure if we really need to do anything yet.
+    *
+    * Not sure if the above is also the case for ORCJIT, but we need set CPU
+    * manually since we don't use JITTargetMachineBuilder::detectHost()
+    */
+
+#if DETECT_ARCH_PPC_64 == 1
+   /*
+    * Large programs, e.g. gnome-shell and firefox, may tax the addressability
+    * of the Medium code model once dynamically generated JIT-compiled shader
+    * programs are linked in and relocated.  Yet the default code model as of
+    * LLVM 8 is Medium or even Small.
+    * The cost of changing from Medium to Large is negligible:
+    * - an additional 8-byte pointer stored immediately before the shader entrypoint;
+    * - change an add-immediate (addis) instruction to a load (ld).
+    */
+   JTMB.setCodeModel(CodeModel::Large);
+
+#if UTIL_ARCH_LITTLE_ENDIAN
+   /*
+    * Versions of LLVM prior to 4.0 lacked a table entry for "POWER8NVL",
+    * resulting in (big-endian) "generic" being returned on
+    * little-endian Power8NVL systems.  The result was that code that
+    * attempted to load the least significant 32 bits of a 64-bit quantity
+    * from memory loaded the wrong half.  This resulted in failures in some
+    * Piglit tests, e.g.
+    * .../arb_gpu_shader_fp64/execution/conversion/frag-conversion-explicit-double-uint
+    */
+   if (MCPU == "generic")
+      MCPU = "pwr8";
+#endif
+#endif
+
+#if DETECT_ARCH_MIPS64 == 1
+   /*
+    * ls3a4000 CPU and ls2k1000 SoC is a mips64r5 compatible with MSA SIMD
+    * instruction set implemented, while ls3a3000 is mips64r2 compatible
+    * only. getHostCPUName() return "generic" on all loongson
+    * mips CPU currently. So we override the MCPU to mips64r5 if MSA is
+    * implemented, feedback to mips64r2 for all other ordinary mips64 cpu.
+    */
+   if (MCPU == "generic")
+      MCPU = util_get_cpu_caps()->has_msa ? "mips64r5" : "mips64r2";
+#endif
+
+#if DETECT_ARCH_RISCV64 == 1
+   /**
+    * should be fixed with https://reviews.llvm.org/D121149 in llvm 15,
+    * set it anyway for llvm 14
+    */
+   if (MCPU == "generic")
+      MCPU = "generic-rv64";
+
+   JTMB.setCodeModel(CodeModel::Medium);
+   JTMB.setRelocationModel(Reloc::PIC_);
+#endif
+
+#if DETECT_ARCH_RISCV32 == 1
+   /**
+    * should be fixed with https://reviews.llvm.org/D121149 in llvm 15,
+    * set it anyway for llvm 14
+    */
+   if (MCPU == "generic")
+      MCPU = "generic-rv32";
+
+   JTMB.setCodeModel(CodeModel::Medium);
+   JTMB.setRelocationModel(Reloc::PIC_);
+#endif
+
+   JTMB.setCPU(MCPU);
+   if (gallivm_debug & (GALLIVM_DEBUG_IR | GALLIVM_DEBUG_ASM | GALLIVM_DEBUG_DUMP_BC)) {
+      debug_printf("llc -mcpu option: %s\n", MCPU.c_str());
+   }
+
+   return JTMB;
+}
+
+
+} /* Anonymous namespace */
+
+bool
+lp_build_init(void)
+{
+   (void)LPJit::get_instance();
+   return true;
+}
+
+bool
+init_gallivm_state(struct gallivm_state *gallivm, const char *name,
+                   lp_context_ref *context, struct lp_cached_code *cache)
+{
+   assert(!gallivm->context);
+   assert(!gallivm->_ts_context);
+   assert(!gallivm->module);
+
+   if (!lp_build_init())
+      return false;
+
+   // cache is not implemented
+   gallivm->cache = cache;
+   if (gallivm->cache)
+      gallivm->cache->data_size = 0;
+
+   gallivm->_ts_context = context->ref;
+   gallivm->context = LLVMOrcThreadSafeContextGetContext(context->ref);
+
+   gallivm->module_name = LPJit::get_unique_name(name);
+   gallivm->module = LLVMModuleCreateWithNameInContext(gallivm->module_name,
+                                                       gallivm->context);
+#if DETECT_ARCH_X86 == 1
+   lp_set_module_stack_alignment_override(gallivm->module, 4);
+#endif
+   gallivm->builder = LLVMCreateBuilderInContext(gallivm->context);
+   gallivm->_per_module_jd = LPJit::create_jit_dylib(gallivm->module_name);
+
+   gallivm->target = LLVMCreateTargetDataLayout(LPJit::get_instance()->tm);
+
+   lp_build_coro_declare_malloc_hooks(gallivm);
+   return true;
+}
+
+struct gallivm_state *
+gallivm_create(const char *name, lp_context_ref *context,
+               struct lp_cached_code *cache){
+   struct gallivm_state *gallivm;
+
+   gallivm = CALLOC_STRUCT(gallivm_state);
+   if (gallivm) {
+      if (!init_gallivm_state(gallivm, name, context, cache)) {
+         FREE(gallivm);
+         gallivm = NULL;
+      }
+   }
+
+   assert(gallivm != NULL);
+   return gallivm;
+}
+
+void
+gallivm_destroy(struct gallivm_state *gallivm)
+{
+   LPJit::remove_jd(gallivm->_per_module_jd);
+   gallivm->_per_module_jd = nullptr;
+}
+
+void
+gallivm_free_ir(struct gallivm_state *gallivm)
+{
+   if (gallivm->module)
+      LLVMDisposeModule(gallivm->module);
+   FREE(gallivm->module_name);
+
+   if (gallivm->target) {
+      LLVMDisposeTargetData(gallivm->target);
+   }
+
+   if (gallivm->builder)
+      LLVMDisposeBuilder(gallivm->builder);
+
+   gallivm->target = NULL;
+   gallivm->module=NULL;
+   gallivm->module_name=NULL;
+   gallivm->builder=NULL;
+   gallivm->context=NULL;
+   gallivm->_ts_context=NULL;
+   gallivm->cache=NULL;
+   LPJit::deregister_gallivm_state(gallivm);
+}
+
+void
+gallivm_add_global_mapping(struct gallivm_state *gallivm, LLVMValueRef sym, void* addr)
+{
+   LPJit::add_mapping_to_jd(sym, addr, gallivm->_per_module_jd);
+}
+
+void
+gallivm_compile_module(struct gallivm_state *gallivm)
+{
+   lp_init_printf_hook(gallivm);
+   gallivm_add_global_mapping(gallivm, gallivm->debug_printf_hook,
+         (void *)debug_printf);
+
+   lp_init_clock_hook(gallivm);
+   gallivm_add_global_mapping(gallivm, gallivm->get_time_hook,
+         (void *)os_time_get_nano);
+
+   lp_build_coro_add_malloc_hooks(gallivm);
+
+   LPJit::add_ir_module_to_jd(gallivm->_ts_context, gallivm->module,
+      gallivm->_per_module_jd);
+   /* ownership of module is now transferred into orc jit,
+    * disallow modifying it
+    */
+   LPJit::register_gallivm_state(gallivm);
+   gallivm->module = nullptr;
+
+   /* defer compilation till first lookup by gallivm_jit_function */
+}
+
+func_pointer
+gallivm_jit_function(struct gallivm_state *gallivm,
+                     LLVMValueRef func, const char *func_name)
+{
+   return pointer_to_func(
+      LPJit::lookup_in_jd(func_name, gallivm->_per_module_jd));
+}
diff --git a/src/gallium/auxiliary/meson.build b/src/gallium/auxiliary/meson.build
index 0f23a7889db..7cf8c9591b5 100644
--- a/src/gallium/auxiliary/meson.build
+++ b/src/gallium/auxiliary/meson.build
@@ -346,7 +346,6 @@ if draw_with_llvm
     'gallivm/lp_bld_gather.c',
     'gallivm/lp_bld_gather.h',
     'gallivm/lp_bld.h',
-    'gallivm/lp_bld_init.c',
     'gallivm/lp_bld_init_common.c',
     'gallivm/lp_bld_init.h',
     'gallivm/lp_bld_intr.c',
@@ -401,6 +400,11 @@ if draw_with_llvm
     'nir/nir_to_tgsi_info.c',
     'nir/nir_to_tgsi_info.h',
   )
+  if llvm_with_orcjit
+    files_libgallium += files('gallivm/lp_bld_init_orc.cpp',)
+  else
+    files_libgallium += files('gallivm/lp_bld_init.c',)
+  endif
 endif
 
 files_libgalliumvl = files(
diff --git a/src/gallium/drivers/llvmpipe/lp_state_cs.c b/src/gallium/drivers/llvmpipe/lp_state_cs.c
index d073228d173..f715db67b1c 100644
--- a/src/gallium/drivers/llvmpipe/lp_state_cs.c
+++ b/src/gallium/drivers/llvmpipe/lp_state_cs.c
@@ -1274,9 +1274,16 @@ generate_variant(struct llvmpipe_context *lp,
 
    generate_compute(lp, shader, variant);
 
+#if GALLIVM_USE_ORCJIT
+/* module has been moved into ORCJIT after gallivm_compile_module */
+   variant->nr_instrs += lp_build_count_ir_module(variant->gallivm->module);
+
+   gallivm_compile_module(variant->gallivm);
+#else
    gallivm_compile_module(variant->gallivm);
 
    variant->nr_instrs += lp_build_count_ir_module(variant->gallivm->module);
+#endif
 
    variant->jit_function = (lp_jit_cs_func)
       gallivm_jit_function(variant->gallivm, variant->function, variant->function_name);
diff --git a/src/gallium/drivers/llvmpipe/lp_state_fs.c b/src/gallium/drivers/llvmpipe/lp_state_fs.c
index 18256ff5a44..7728b53366a 100644
--- a/src/gallium/drivers/llvmpipe/lp_state_fs.c
+++ b/src/gallium/drivers/llvmpipe/lp_state_fs.c
@@ -3916,9 +3916,16 @@ generate_variant(struct llvmpipe_context *lp,
     * Compile everything
     */
 
+#if GALLIVM_USE_ORCJIT
+/* module has been moved into ORCJIT after gallivm_compile_module */
+   variant->nr_instrs += lp_build_count_ir_module(variant->gallivm->module);
+
+   gallivm_compile_module(variant->gallivm);
+#else
    gallivm_compile_module(variant->gallivm);
 
    variant->nr_instrs += lp_build_count_ir_module(variant->gallivm->module);
+#endif
 
    if (variant->function[RAST_EDGE_TEST]) {
       variant->jit_function[RAST_EDGE_TEST] = (lp_jit_frag_func)
-- 
2.46.0

